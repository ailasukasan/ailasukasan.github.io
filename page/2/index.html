



<!DOCTYPE html>
<html lang="en">
<head>

<!--
    <script src="/js/leaves.js"></script>
-->
    <!-- 爆炸红心效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.9' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--流星雨背景
<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
-->
    <meta charset="utf-8" />
    <title>PHM&#39;s world</title>
    <meta name="author" content="ailasukasan" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>歡迎來到烏托邦的世界</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>PHM&#39;S WORLD</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;PHM</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;PHM&#39;S WORLD</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">PHM</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>PHM&#39;s world</h1>
                <h3>Create an Aircraft To Utopia</h3>
                <h5></h5>
                                <!-- 这里是在create ...to utopia下方加入文字-->
                <a target="_blank" rel="noopener" href="https://www.nasa.gov/">To be an Astronaut</a>

                                <!-- 这里是在create ...to utopia下方加入文字-->
                                <!-- QQ和推特链接模块结束 -->
            </div>
        </span>

    </div>

</div>
<div id="home-posts-wrap" true ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/04/01/%E6%89%93%E5%BC%80%E8%BF%99%E4%B8%AA/">
        <h2 class="post-title">打开这个</h2>
    </a>



    <div class="category-and-date">

        


        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/1
        </span>



        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>打开一下</p>

            
        </div>
    </div>
<!--
    <div class="description">
        <div class="content" v-pre>
            
            <p>打开一下</p>

            
        </div>
    </div>
-->
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%8B%E5%90%A7/" style="color: #ff7d73">打开一下吧</a>
        </span>
        
    </div>

<!--
    <span class="icon">
        <i class="fa-solid fa-tags fa-fw"></i>
    </span>

    <span class="date">
        <span class="icon">
            <i class="fa-solid fa-calendar fa-fw"></i>
        </span>
        2024/4/1
    </span>
-->
    <a href="/2024/04/01/%E6%89%93%E5%BC%80%E8%BF%99%E4%B8%AA/" class="go-post">阅读全文</a>

</div>

<div class="post">
    <a href="/2024/04/01/pytorch%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/">
        <h2 class="post-title">pytorch和机器学习算法</h2>
    </a>



    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                基础知识
            </a>
        </span>

        


        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/1
        </span>



        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
        </div>
    </div>
<!--
    <div class="description">
        <div class="content" v-pre>
            
            <h6><span id="槽点太多了">槽点太多了…</span></h6><p>图片显示又卡bug了<del>（笑）</del></p>
<h2><span id="21-tensor操作">2.1 Tensor操作</span></h2><p>理解的核心：张量其实就是矩阵</p>
<p>又叫张量操作</p>
<p>多维数组或者矩阵</p>
<h5><span id="性质">性质：</span></h5><h6><span id="1张量属性">1.张量属性</span></h6><pre><code class="python">#形状、数据类型
# 查看张量的形状
print(x.size())  # 输出: torch.Size([2, 3])

# 查看张量的数据类型
print(x.dtype)  # 输出: torch.int64
</code></pre>
<h6><span id="2索引和切片">2.索引和切片</span></h6><pre><code class="python"># 获取张量的某个元素
print(x[0, 1])  # 输出: tensor(2)

# 切片操作
print(x[:, 1])  # 获取第二列的所有元素
</code></pre>
<p>切片其实就是选取部分数据</p>
<p>切片操作举例：</p>
<pre><code class="python">import torch
# 创建一个 3x3 的张量
x = torch.tensor([[1, 2, 3],
                  [4, 5, 6],
                  [7, 8, 9]])

# 选择第一行的所有元素
slice1 = x[0, :]
print(&quot;选择第一行的所有元素:&quot;)
print(slice1)  # 输出: tensor([1, 2, 3])

# 选择第一列的所有元素
slice2 = x[:, 0]
print(&quot;\n选择第一列的所有元素:&quot;)
print(slice2)  # 输出: tensor([1, 4, 7])

# 选择第一行到第二行（不包括第二行）的所有元素，以及第一列到第二列（不包括第二列）的所有元素
slice3 = x[0:2, 0:2]
print(&quot;\n选择第一行到第二行、第一列到第二列的所有元素:&quot;)
print(slice3)
# 输出:
# tensor([[1, 2],
#         [4, 5]])

# 修改切片后的值会影响原始张量
slice3[0, 0] = 10
print(&quot;\n修改切片后的值会影响原始张量:&quot;)
print(x)
# 输出:
# tensor([[10,  2,  3],
#         [ 4,  5,  6],
#         [ 7,  8,  9]])
</code></pre>
<h6><span id="3数学操作">3.数学操作</span></h6><pre><code class="python"># 加法
result = torch.add(x, 2)

# 逐元素乘法
result = torch.mul(x, 2)

# 求和
result = torch.sum(x)

# 矩阵乘法
matrix1 = torch.tensor([[1, 2], [3, 4]])
matrix2 = torch.tensor([[5, 6], [7, 8]])
result = torch.matmul(matrix1, matrix2)
</code></pre>
<h6><span id="4形状操作">4.形状操作</span></h6><p>相当于矩阵的操作</p>
<p>例如：</p>
<pre><code class="python">import torch

# 创建一个张量
x = torch.tensor([[1, 2, 3],
                  [4, 5, 6]])

# 改变张量形状为 (3, 2)
reshaped_tensor = x.view(3, 2)

# 打印改变形状后的张量
print(&quot;改变形状后的张量:&quot;)
print(reshaped_tensor)
#改变形状后的张量:
tensor([[1, 2],
        [3, 4],
        [5, 6]])
</code></pre>
<p>函数：</p>
<pre><code>1.# 改变张量形状
reshaped_tensor = x.view(3, 2)

2.# 转置
transposed_tensor = x.t()

3.# 拼接张量
concatenated_tensor = torch.cat((x, x), dim=0)  # 沿着行拼接
</code></pre>
<h6><span id="5广播">5.广播</span></h6><p>广播就是改变维度不同的张量使得之间可以进行数学操作，比如：</p>
<pre><code class="python">x = torch.tensor([[1, 2, 3],
                  [4, 5, 6]])

y = torch.tensor([10, 20, 30])
#广播后：
y_broadcasted = torch.tensor([[10, 20, 30],
                              [10, 20, 30]])
#结果：
result = x + y_broadcasted
# 结果为
# [[ 11,  22,  33],
#  [ 14,  25,  36]]
</code></pre>
<h2><span id="23-自动求导">2.3 自动求导</span></h2><p>理解的核心：梯度其实就是导数</p>
<p><code>requires_grad=True</code>是一种标记，pytorch会跟踪x上的所有操作，在需要时自动计算x的相关操作</p>
<p>分为三个步骤：</p>
<h6><span id="1初始化tensor">1.初始化tensor</span></h6><p>初始化矩阵，并标记可以自动求导</p>
<pre><code class="python">import torch

# 创建一个张量并设置 requires_grad=True
x = torch.tensor([2.0], requires_grad=True)
</code></pre>
<h6><span id="2定义函数表达式">2.定义函数表达式</span></h6><p>正规的表达是：定义计算操作</p>
<pre><code class="python"># 定义计算图
y = x ** 2 + 3 * x + 1
</code></pre>
<h6><span id="3计算梯度">3.计算梯度</span></h6><p>涉及到两个函数：</p>
<p><code>backward()</code>计算梯度</p>
<p><code>grad()</code>访问梯度</p>
<pre><code class="python"># 自动计算梯度
y.backward()

# 访问梯度
print(x.grad)  # 输出: tensor([7.])
</code></pre>
<h2><span id="3-pytorch-神经网络">3. PyTorch 神经网络</span></h2><h3><span id="理解神经网络">理解神经网络：</span></h3><h4><span id="1机器学习基础">1.机器学习基础</span></h4><h5><span id="机器学习的基本概念和算法">机器学习的基本概念和算法</span></h5><p>如：</p>
<h6><span id="1监督学习">1.监督学习</span></h6><p>核心思想：从带有标签的数据中学习出一个模型</p>
<p>监督学习的目标是从已标记的数据中学习到一个从输入到输出的映射关系。</p>
<p>标记的数据（有标签的数据）指的是在机器学习或数据分析任务中，每个数据样本都附带了与之相关联的标签或输出信息。</p>
<h6><span id="2无监督学习">2.无监督学习</span></h6><p>没有明确目的的机器学习，常用于发现异常数据</p>
<p>常见的两类无监督学习算法：聚类、降维</p>
<p>K均值聚类：就是制定分组的数量为K，自动进行分组。</p>
<p>层次聚类：不知道应该分为几类，那么层次聚类就比较适合了。层次聚类会构建一个多层嵌套的分类，类似一个树状结构。</p>
<p>降维算法：</p>
<p>主成分分析：是把多指标转化为少数几个综合指标。</p>
<p>主成分分析经常用减少数据集的维数，同时保持数据集的对方差贡献最大的特征。这是通过保留低阶主成分，忽略高阶主成分做到的。这样低阶成分往往能够保留住数据的最重要方面。</p>
<p>从未标记的数据中学习，没有对应的输出标签。与监督学习不同，无监督学习的目标是在数据中发现隐藏的结构或模式，而不是进行特定的预测或分类。</p>
<p>在无监督学习中，模型试图从数据中学习出一些有用的特征、关系或表示，以便对数据进行更好地理解、组织或压缩。无监督学习的主要任务通常包括聚类（Clustering）、降维（Dimensionality Reduction）、密度估计（Density Estimation）等。</p>
<p>未标记的数据（无标签的数据）则是指在数据集中缺少与之关联的标签或输出信息的数据样本。</p>
<h6><span id="3回归">3.回归</span></h6><h6><span id="4分类">4.分类</span></h6><h6><span id="5聚类">5.聚类</span></h6><p>聚类是将数据集中的样本分组到多个不同的类别中，使得同一类别内的样本更加相似，而不同类别之间的样本差异更大。常见的聚类算法包括K均值聚类、层次聚类等。</p>
<h5><span id="常见的机器学习算法">常见的机器学习算法</span></h5><h6><span id="1线性回归">1.线性回归</span></h6><ul>
<li>线性回归是一种用于建立输入变量（特征）和连续输出变量之间关系的回归模型。</li>
<li>基本假设是输入变量和输出变量之间存在线性关系。线性回归模型通过拟合一条直线（在一维情况下）或超平面（在高维情况下），使得输入变量和输出变量之间的残差平方和最小化。</li>
<li>线性回归的输出是连续的实数值，用于对实数域的目标变量进行预测。例如，房价预测、销售量预测等。</li>
</ul>
<h6><span id="2逻辑回归">2.逻辑回归</span></h6><ul>
<li>逻辑回归是一种用于解决<strong>二分类问题</strong>的回归模型，虽然其名称中包含“回归”，但实际上是一种分类算法。</li>
<li>逻辑回归模型利用逻辑函数（也称为Sigmoid函数）将输入特征的线性组合映射到[0, 1]区间内的概率值，表示样本属于某个类别的概率。</li>
<li>在训练阶段，逻辑回归模型通过最大化似然函数或最小化交叉熵损失函数来优化模型参数。通常使用梯度下降等优化算法来实现。</li>
<li>逻辑回归的<strong>输出是一个概率值</strong>，通常根据设定的阈值（通常为0.5）进行分类，小于阈值的样本被划分为一类，大于等于阈值的样本被划分为另一类。</li>
</ul>
<h6><span id="逻辑回归和线性回归的区别">逻辑回归和线性回归的区别</span></h6><ol>
<li><p><strong>输出类型：</strong></p>
<ul>
<li>线性回归的输出是连续的实数值，可以是任意的实数。</li>
<li>逻辑回归的输出是一个介于0和1之间的概率值，通常表示某个事件发生的概率。</li>
</ul>
</li>
<li><p><strong>模型形式：</strong></p>
<ul>
<li><p>线性回归模型使用线性函数来建模输入特征和输出之间的关系。其形式为：<br>$$<br>y &#x3D; w_0 + w_1x_1 + w_2x_2 + … + w_nx_n<br>$$<br>其中 (y) 是输出变量，(w) 是权重参数，(x) 是输入特征。</p>
</li>
<li><p>逻辑回归模型使用逻辑函数（也称为Sigmoid函数）来建模输入特征和输出之间的关系。其形式为：<br>$$<br>p(y&#x3D;1|x) &#x3D; \frac{1}{1 + e^{-(w_0 + w_1x_1 + w_2x_2 + … + w_nx_n)}}<br>$$<br>其中 (p(y&#x3D;1|x)) 表示给定输入特征 (x) 条件下输出 (y) 为1的概率。</p>
</li>
</ul>
</li>
<li><p><strong>损失函数：</strong></p>
<ul>
<li><p>线性回归通常使用平方损失函数（Mean Squared Error，均方差）来衡量预测值与真实值之间的差异。</p>
</li>
<li><p>逻辑回归通常使用对数损失函数（Log Loss）或交叉熵损失函数（因为p ( x ) p(x)p(x)是目标分布，所以用p pp来表示该事件是最好的。但是现在用了q ( x ) q(x)q(x)，多了一些不确定性因素，这个增加的信息量就是相对熵。<br>（Cross-entropy Loss）来衡量预测概率与真实标签之间的差异。<br>$$<br>DKL(p∥q)&#x3D;i&#x3D;1∑Np(xi)log(q(xi)p(xi))<br>$$</p>
</li>
</ul>
</li>
<li><p><strong>模型输出：</strong></p>
<ul>
<li>线性回归模型的输出是一个实数值，可以是任意的实数。</li>
<li>逻辑回归模型的输出是一个概率值，通常大于0且小于1，表示某个事件发生的概率。</li>
</ul>
</li>
</ol>
<h6><span id="3决策树">3.决策树</span></h6><p>用于解决分类和回归问题</p>
<p>每个<strong>内部节点表示一个特征&#x2F;属性</strong>，</p>
<p>每个<strong>叶子节点表示一个类别标签或连续值输出。</strong></p>
<p>是一种：非参数化模型：</p>
<p>非参数模型并不是说模型中没有参数！而是参数很多或者说参数不确定。</p>
<p>例如：</p>
<p>假设你正在研究一种新药对患者疾病症状的影响。你收集了一些关于患者的基本信息（如年龄、性别、体重等）以及他们接受治疗前后的症状严重程度。你想要建立一个模型来预测药物治疗对症状改善的影响。</p>
<p>如果你选择使用K近邻算法（K-Nearest Neighbors，KNN）来建立预测模型，那么你不需要做出特定的函数形式的假设。KNN算法会根据患者的特征与其他患者的特征之间的相似度，来预测该患者的症状改善程度。在这种情况下，模型不对函数形式做出假设，而是通过学习数据中的模式和结构来进行预测。</p>
<p>它<strong>不需要假设特定的函数形式</strong>，而是<strong>根据数据的特征来进行预测</strong>。相比之下，线性回归模型是一种参数化模型，因为它假设了特定的线性函数形式。</p>
<p>对比：</p>
<p>在使用非参数化模型（如决策树、K近邻算法等）时，通常不需要像参数化模型那样手动初始化模型的参数。相反，非参数化模型会根据训练数据自动构建模型，学习数据中的模式和结构。在决策树的情况下，算法会自动选择特征进行节点分割，并根据数据集的特征和标签来构建树状结构。</p>
<p>而在使用参数化模型时，通常需要手动初始化模型的参数，并选择合适的模型结构。例如，在线性回归模型中，需要手动选择模型的权重参数，并且假设特定的线性函数形式。这些参数通常是在训练过程中通过优化算法进行调整和学习的。</p>
<p>因此，非参数化模型通常具有更强的灵活性和自动化，因为它们不需要假设特定的函数形式或参数数量。相比之下，参数化模型通常需要更多的人为干预和手动设置。</p>
<p>但是：非参数模型仍然需要自己去手动设置和探索一些特征</p>
<h6><span id="特征的提取">特征的提取：</span></h6><ol>
<li><strong>基本特征提取：</strong> 这涉及从原始数据中提取最基本的特征，例如数值型特征（如年龄、收入）、类别型特征（如性别、城市）等。这些特征通常是直接从数据中提取的，不需要额外的处理。</li>
<li><strong>特征变换：</strong> 特征变换可以将原始特征进行数学变换，以获得更具代表性或更有意义的特征。例如，对数变换、平方变换、指数变换等可以用于改变特征的分布或增强某些特征之间的相关性。</li>
<li><strong>特征组合：</strong> 特征组合可以将多个原始特征进行组合，以创建新的特征。这可以通过加法、乘法、除法等运算来实现。例如，将身高和体重结合起来创建BMI（身体质量指数）特征。</li>
<li><strong>离散化：</strong> 将连续型特征转换为离散型特征的过程称为离散化。这可以通过分箱（binning）或分段（segmentation）来实现。例如，将年龄划分为不同的年龄组。</li>
<li><strong>文本特征提取：</strong> 对于文本数据，特征提取通常涉及将文本转换为数值特征的过程。常见的文本特征提取方法包括词袋模型（Bag-of-Words）、TF-IDF（Term Frequency-Inverse Document Frequency）等。</li>
<li><strong>时间序列特征提取：</strong> 对于时间序列数据，特征提取可以涉及计算统计特征（如均值、方差）、滑动窗口统计特征、时序特征（如时间差、周期性特征）等。</li>
<li><strong>高级特征工程：</strong> 针对具体问题，可能需要进行更高级的特征工程，例如基于领域知识的特征构建、特征选择、特征降维等。（也即提取主成分）</li>
</ol>
<h6><span id="4支持向量机">4.支持向量机</span></h6><p>是一种监督学习算法</p>
<p>找到一个最优平面（最优超品面），将不同类别的数据点有效地分隔开来</p>
<p>支持向量：在SVM中，支持向量是离超平面最近的一些数据点。这些支持向量对于定义超平面的位置和方向至关重要。换句话说，支持向量决定了最大间隔超平面的形状和位置。</p>
<p>核函数：</p>
<p><strong>将低维的原始特征空间映射到一个更高维的特征空间</strong>，原始空间中<strong>线性不可分的数据在新的高维空间可能会变得线性可分</strong>，使得支持向量机（SVM）等线性分类器能够更好地完成分类任务。</p>
<p>假设我们有一组数据，这些数据在二维空间中是线性不可分的，也就是说，无法通过一条直线将两个类别的数据完全分开。但是，我们希望使用SVM来解决这个分类问题。</p>
<p>核函数的作用就是将原始的特征空间映射到一个更高维的空间，使得在这个高维空间中数据变得线性可分。换句话说，核函数可以将非线性问题转换为线性问题来处理。</p>
<p>例如，考虑一个二维的数据集，包含了横坐标和纵坐标两个特征。如果我们使用线性核函数，那么SVM将在二维空间中寻找一条直线来分隔两个类别。但是，如果数据在二维空间中不是线性可分的，那么使用线性核函数可能无法得到一个很好的分类结果。</p>
<p>这时候，我们可以使用一个非线性的核函数，比如高斯核函数（也称为径向基函数核，RBF核）。高斯核函数的作用是将原始的二维空间映射到一个无限维的高维空间，使得数据在高维空间中变得线性可分。在高维空间中，SVM就可以找到一个超平面来完美地分隔两个类别的数据点。</p>
<p>因此，核函数允许我们在低维空间中处理复杂的非线性问题，并且在高维空间中寻找一个线性的超平面来完成分类任务。常用的核函数包括高斯核函数、多项式核函数、Sigmoid核函数等，具体的选择取决于数据的性质和分类问题的需求。</p>
<p>核函数的作用是隐式地定义了一个高维空间中的特征映射，而无需显式地计算出这个映射。常用的核函数有：</p>
<ol>
<li><strong>线性核（Linear Kernel）：</strong> 直接进行线性分隔，适用于数据线性可分的情况。</li>
<li><strong>多项式核（Polynomial Kernel）：</strong> 将数据映射到多项式特征空间，通过多项式函数进行分隔，适用于数据的非线性分隔情况。</li>
<li><strong>径向基函数核（Radial Basis Function，RBF Kernel）：</strong> 将数据映射到无穷维的特征空间，通过高斯函数进行分隔，适用于复杂的非线性分隔情况。</li>
</ol>
<h4><span id="2深度学习基础">2.深度学习基础</span></h4><h5><span id="基本术语">基本术语</span></h5><h6><span id="1损失函数">1.损失函数</span></h6><p>模型预测值与真实标签之间的差异程度，是训练过程中的优化目标。</p>
<p>理解：是一个函数，函数的值是用于描述预测值和真实值之间的误差的</p>
<p>作用：用损失函数来计算在<strong>测试数据（不仅仅是测试集，在训练过程中也很重要）</strong>上的表现，通过最小化损失函数，可以使得模型的预测值接近真实值，提高模型的准确性和性能</p>
<p>最小化损失函数的方法：</p>
<p><strong>梯度下降法（Gradient Descent）</strong>：</p>
<p>沿着损失函数的<strong>负梯度方向</strong>调整参数来最小化损失函数。</p>
<p>在每一次迭代中，根据损失函数关于模型参数的梯度方向和大小来更新参数，使得损失函数的值逐渐减小。</p>
<p><strong>随机梯度下降法（Stochastic Gradient Descent，SGD）</strong>：</p>
<p>梯度下降法的一种变体，每次迭代使用<strong>一个随机小批量的样本</strong>来计算损失函数的梯度，并更新参数。SGD通常比批量梯度下降法更快地收敛，并且在大规模数据集上更有效。</p>
<p><strong>自适应学习率优化器（Adaptive Learning Rate Optimizers）</strong>：</p>
<p><strong>学习率调度（Learning Rate Scheduling）</strong>：</p>
<p>是一种超参数</p>
<p>学习率决定了模型在参数空间中沿着梯度方向更新的幅度，即每一步参数更新的大小</p>
<p><strong>正则化（Regularization）</strong>：</p>
<p><strong>过大的参数会导致过拟合</strong></p>
<p>本质是：限制模型的能力</p>
<p>向损失函数添加额外的<strong>惩罚项</strong>来防止模型过拟合训练数据。正则化的惩罚函数通常包括 L1 正则化和 L2 正则化两种常见形式。</p>
<p>L2 正则化通过迫使模型的参数趋向于较小的值，从而降低了模型的复杂度</p>
<p>有以下的损失函数：</p>
<ol>
<li><p><strong>均方误差损失（Mean Squared Error，MSE）</strong>：</p>
<ul>
<li><p>表达式：<br>$$<br>\text{MSE} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} (y_i - \hat{y}_i)^2<br>$$</p>
</li>
<li><p>适用于回归问题，用于衡量模型预测值与真实值之间的平均平方差。</p>
</li>
</ul>
</li>
<li><p><strong>交叉熵损失（Cross-Entropy Loss）</strong>：</p>
<ul>
<li><p>二分类交叉熵损失：<br>$$<br> \text{CE} &#x3D; -\frac{1}{n} \sum_{i&#x3D;1}^{n} [y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i)]<br>$$</p>
</li>
<li><p>多分类交叉熵损失：<br>$$<br>\text{CE} &#x3D; -\frac{1}{n} \sum_{i&#x3D;1}^{n} \sum_{j&#x3D;1}^{C} y_{ij} \log(\hat{y}_{ij})<br>$$</p>
</li>
<li><p>适用于分类问题，用于衡量模型预测的概率分布与真实标签的差异。</p>
</li>
</ul>
</li>
<li><p><strong>对数损失（Log Loss）</strong>：</p>
<ul>
<li><p>表达式：<br>$$<br> \text{Log Loss} &#x3D; -\frac{1}{n} \sum_{i&#x3D;1}^{n} [y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i)]<br>$$</p>
</li>
<li><p>适用于二分类或多分类问题，与交叉熵损失类似，用于衡量模型预测的概率分布与真实标签的差异。</p>
</li>
</ul>
</li>
<li><p><strong>Hinge Loss</strong>：</p>
<ul>
<li><p>表达式：<br>$$<br> \text{Hinge Loss} &#x3D; \max(0, 1 - y \cdot \hat{y})<br>$$</p>
</li>
<li><p>适用于支持向量机（SVM）等分类模型，用于衡量模型输出与真实标签之间的间隔。</p>
</li>
</ul>
</li>
<li><p><strong>Huber Loss</strong>：</p>
<ul>
<li><p>表达式：<br>$$<br>\text{Huber Loss} &#x3D; \begin{cases} \frac{1}{2}(y - \hat{y})^2, &amp; \text{if } |y - \hat{y}| \leq \delta \ \delta(|y - \hat{y}| - \frac{1}{2}\delta), &amp; \text{otherwise} \end{cases}<br>$$</p>
</li>
<li><p>适用于回归问题，比均方误差损失对异常值更加鲁棒。</p>
</li>
</ul>
</li>
</ol>
<h6><span id="2优化器">2.优化器</span></h6><p>用于调整模型参数以最小化损失函数的算法，如随机梯度下降（SGD）、Adam、RMSProp 等。</p>
<p>这些算法涉及到手动调参数：</p>
<p>有<strong>网格搜索</strong>：网格对每个超参数组合进行模型训练和评估，从而找到性能最佳的超参数组合。</p>
<p>关键步骤：交叉验证：</p>
<p>对于每个参数组合，使用交叉验证方法来评估模型在验证集上的性能。通常使用 K 折交叉验证，将训练数据分成 K 个子集，在每次迭代中使用 K-1 个子集进行训练，剩余的一个子集用于验证。重复 K 次后取平均得到模型的性能评估指标，如准确率、F1 值等。（K通常是5或10）</p>
<p>F1 值是精确率和召回率的调和平均数</p>
<h6><span id="3批量处理">3.批量处理</span></h6><p>在训练过程中，将训练数据分成多个批次进行训练，以加快训练速度和减少内存占用。</p>
<h6><span id="4神经元">4.神经元</span></h6><p>神经网络的基本组成单元</p>
<p>人工神经元接收来自其他神经元或外部源的输入，每个输入都有一个相关的权值（w），它是根据该输入对当前神经元的重要性来确定的，<strong>对该输入加权并与其他输入求和后，经过一个激活函数 f，计算得到该神经元的输出</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/9a29d5391ee744b5bc44e20833acb815.png#pic_center" alt="在这里插入图片描述"></p>
<h6><span id="5激活函数">5.激活函数</span></h6><p>引入了非线性、解决了线性不可分问题、稀疏性和正则化</p>
<p>用来求得神经元的输出的</p>
<p>有一些常用的激活函数</p>
<p><strong>分层表示</strong>：神经网络通常是分层的结构，由多个层次组成，每一层都负责不同层次的特征提取和抽象表示。底层包含原始数据的基本特征，而高层则包含更加抽象和复杂的特征。</p>
<h6><span id="6前向传播-反向传播">6.前向传播、反向传播</span></h6><p>神经网络是通过反向传播算法实现学习的。下面是实现学习的基本步骤：</p>
<ol>
<li><p><strong>前向传播</strong>：首先，将输入数据通过神经网络进行前向传播，从输入层开始逐层向前传递，直到输出层得到网络的预测结果。在每一层中，神经元根据输入数据和连接权重计算出激活值，并通过激活函数得到输出。</p>
</li>
<li><p><strong>计算损失</strong>：将网络的输出与真实标签进行比较，计算预测值与真实值之间的差异，这个差异通常用损失函数来表示。损失函数可以是各种形式，比如均方误差（MSE）、交叉熵等。</p>
</li>
<li><p><strong>反向传播</strong>：接下来，利用反向传播算法计算损失函数对网络参数的梯度。反向传播从损失函数开始，沿着网络的反方向逐层传播梯度，根据链式法则计算每一层参数的梯度。这个过程使得我们能够知道如何调整参数才能降低损失函数的值。</p>
</li>
<li><p><strong>参数更新</strong>：最后，根据梯度下降（或其他优化算法）的原理，利用计算得到的梯度来更新网络中的参数。更新参数后，重复前面的步骤，继续进行前向传播、计算损失和反向传播，直到达到停止条件（如达到最大迭代次数或损失函数收敛）。</p>
</li>
</ol>
<p>通过这个过程，神经网络能够根据输入数据逐渐调整网络参数，使得网络的预测结果逐渐接近真实值，从而实现学习的目的。这就是神经网络是如何通过反向传播算法实现学习的基本过程。</p>
<p>前向传播：（求误差）</p>
<p>反向传播：（误差回传，即修改误差）</p>
<h5><span id="常见的深度学习模型">常见的深度学习模型</span></h5><h6><span id="1如多层感知机mlp">1.如多层感知机（MLP）</span></h6><p>是传统的多层感知机</p>
<p><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20240330222436276.png" alt="image-20240330222436276"></p>
<p>多层感知机（MLP，Multilayer Perceptron）也叫<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&spm=1001.2101.3001.7020">人工神经网络</a>（ANN，Artificial Neural Network），除了输入输出层，它中间可以有多个隐层，最简单的MLP只含一个隐层，即三层的结构，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190623203530221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZnMTM4MjEyNjc4MzY=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>多层感知机层与层之间是全连接的</p>
<p>最底层是输入层，中间是隐藏层，最后是输出层。 </p>
<p>Sigmoid型激活函数</p>
<p><img src="https://img-blog.csdnimg.cn/20190623205326304.png" alt="img"></p>
<p>这个函数通常用做二分类</p>
<p>MLP（多层感知机）中通常会使用随机梯度下降（Stochastic Gradient Descent, SGD）或其变体来训练模型。SGD是一种优化算法，用于更新神经网络中的权重以最小化损失函数。</p>
<p>随机梯度下降和和梯度提升树都是最小化损失函数的算法，但是两者在实现方式上有所不同</p>
<ul>
<li><strong>随机梯度下降</strong> 是一种迭代优化算法，用于更新模型的参数以最小化损失函数。在每次迭代中，它使用单个训练样本的梯度来更新参数。由于每次更新只考虑单个样本，因此更新是随机的。SGD通常用于训练神经网络等大规模数据集和高维特征空间的模型。</li>
<li><strong>梯度提升树</strong> 是一种集成学习技术，它通过迭代地训练弱模型（通常是决策树），并通过优化损失函数的梯度来改进每个模型的性能。在每次迭代中，新模型被构建以减少前一个模型残差的损失。最终，所有模型的预测结果被加权结合以得到最终的预测结果。梯度提升树通常用于回归和分类问题，是一种非常强大且灵活的模型。</li>
</ul>
<p>梯度下降的基本思想是沿着损失函数的负梯度方向更新参数的值，以使得损失函数逐渐减小。<strong>这里的下降表示损失函数的下降</strong></p>
<p>“提升”一词在梯度提升中表示通过迭代地构建和组合模型来提高整体模型的性能。这里的<strong>提升代表模型的功能提升</strong></p>
<h6><span id="2卷积神经网络cnn">2.卷积神经网络（CNN）</span></h6><p>区别于BP神经网络：多层感知机</p>
<p>BP神经网络是指“反向传播神经网络”</p>
<p>BP神经网络通常是指多层感知机（Multi-Layer Perceptron，MLP）。</p>
<ul>
<li>BP神经网络：BP神经网络通常是全连接的，每个神经元与上一层的所有神经元相连，各个层之间的连接权重是可学习的。BP神经网络的隐藏层和输出层可以包含任意数量的神经元。</li>
<li>CNN：CNN包含了卷积层、池化层和全连接层等不同类型的层。在卷积层中，神经元只与输入数据的局部区域相连，并且通过共享权重来提取局部特征。通过卷积和池化操作，CNN能够有效地提取图像等数据中的空间特征，并减少模型参数数量。</li>
</ul>
<p>卷积层：一系列滤波器（卷积核）来扫描输入数据</p>
<p>池化层：</p>
<p>池化窗口？</p>
<p>减少数据空间维度</p>
<p>池化又叫下采样(Dwon sampling), 与之相对的是上采样(Up sampling). 卷积得到的特征图一般需要一个池化层以降低数据量. </p>
<p><img src="https://img-blog.csdnimg.cn/20200109232036372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXBmOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>和卷积一样, 池化也有一个滑动的核, 可以称之为滑动窗口, 上图中滑动窗口的大小为 2 × 2 2\times 22×2, 步幅为 2 22, 每滑动到一个区域, 则取最大值作为输出, 这样的操作称为 Max Pooling. 还可以采用输出均值的方式, 称为 Mean Pooling.</p>
<p>全连接层：是传统的神经网络结构，每个神经元都和前一层所有神经元相连，将卷积层和池化层提取到的特征进行组合和整合，以便最终的分类或回归任务。</p>
<p>卷积操作：</p>
<p>对卷积的理解</p>
<p>卷积：</p>
<p>旋转，相乘、积分</p>
<p>卷积的物理意义！火车进山洞的理解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Di4y1o7vX/?spm_id_from=333.337.search-card.all.click&vd_source=424e5faeb592b5cc55161aba63be3b0a">【卷积】直观形象的实例，10分钟彻底搞懂_哔哩哔哩_bilibili</a></p>
<p>卷积：解决在信号邻域内时域与频域的问题</p>
<p><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20240327234010486.png" alt="image-20240327234010486"></p>
<p>卷积就是对信号进行滤波，系统就是滤波器</p>
<p><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20240327234510477.png" alt="image-20240327234510477"></p>
<p>卷积神经网络：</p>
<p>在把图片交给神经网络之前，先进行卷积的操作</p>
<p>1.图片转化为数字的矩阵</p>
<p>2.然后创建一个3*3的矩阵，叫做卷积核</p>
<p>3.然后开始卷积</p>
<p>意义何在：</p>
<p>被卷积后的图像：经过卷积核（过滤器），提取特征</p>
<p>卷积</p>
<p>对卷积这个名词的理解：<strong>所谓两个函数的卷积，本质上就是先将一个函数翻转，然后进行滑动叠加。</strong></p>
<p>卷积操作是将一个小的窗口（通常称为卷积核或过滤器）在输入图像上滑动，并将卷积核中的权重与输入图像中对应位置的像素值相乘，然后将所有乘积的结果相加，最后得到一个输出值。这个输出值通常对应于输入图像的某种特征，例如边缘、纹理等。</p>
<p>卷：指的是函数的翻转，还有窗口滑动的意思</p>
<p>积：指的是积分、加权求和</p>
<p>关于为什么要积？：</p>
<p>需要把每个像素周边的信息，甚至整个图像都要考虑进来，对当前像素进行某种加权处理。所以说“积”是一种全局的概念，或者是一种混合，两个函数在空间上的一种混合</p>
<p>关于为什么要卷？：</p>
<p>为什么不直接相乘，卷是在空间上添加一种约束，指定了积的时候以什么作为参照。</p>
<p>理解“约束”：</p>
<p>卷积核：</p>
<p>卷积核一般有多个，不同的卷积核处理不同的信息</p>
<p>滤波器：多个卷积核堆叠而成的三维矩阵。在只有一个通道，也就是二维的情况下，卷积核就相当于滤波器。</p>
<p>卷积仍然是线性变换</p>
<p>激活层：引入非线性</p>
<p>全连接层：传统上的神经网络</p>
<p>BP神经网络的实现过程：<img src="https://img-blog.csdnimg.cn/0070a964e66846ba826c8b5633d1cd45.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzI4MzEz,size_16,color_0000FF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>反向传播就是一个负反馈的过程，使得误差变小</p>
<p>池化：</p>
<p>池化操作：为了简化，抓住主要矛盾，忽视次要矛盾，比如每个区域内只选择最大的数字。</p>
<p>池“就是汇集、聚集</p>
<p>权值共享：是在网络的不同位置或不同层之间共享相同的参数（权重）。这意味着在网络的不同部分使用相同的权重来计算特征，而不是为每个部分单独学习不同的权重。常用于具有某种结构或模式的数据。减少了参数数量、提高了网络的泛化能力、降低了过拟合的风险，并且能够更好地利用数据的结构和模式。</p>
<p>局部连接：指的是在神经网络的不同层之间建立连接时，只连接部分神经元，而不是全连接所有神经元。每个神经元仅与输入数据的局部区域进行连接，而不是与整个输入层的所有神经元连接。允许网络更加高效地处理大规模输入数据，</p>
<h6><span id="3循环神经网络rnn">3.循环神经网络（RNN）</span></h6><p>区别：神经网络多感知模型。MLP：神经元数量是预先固定的。每一个神经元都代表一个字或者词</p>
<p>RNN适合于序列分析；</p>
<p>对动态影像添加描述</p>
<p>LSTM是RNN的一种</p>
<p>简单RNN模型：</p>
<h6><span id="4长短期记忆网络lstm">4.长短期记忆网络（LSTM）</span></h6><p>一种时间递归神经网络，<strong>适合于处理和预测时间序列中间隔和延迟相对较长的重要事件</strong>。</p>
<p>解决循环神经网络RNN结构中存在的“梯度消失”问题而提出的，是一种特殊的循环神经网络。</p>
<p>在深度学习中，梯度通常指的是损失函数相对于模型参数的梯度。</p>
<h6><span id="5变换器transformer">5.变换器（Transformer）</span></h6><p>通过自注意力机制来捕捉序列中的关系</p>
<p>有效地捕捉长距离依赖关系，这使得它在处理自然语言处理任务时非常有效。</p>
<p>自注意力机制：自注意力机制（Self-Attention Mechanism）是一种用于处理序列数据的机制，主要用于捕捉序列中<strong>不同位置之间的依赖关系</strong>。它在给定序列中的每个元素上计算权重，以表示与该元素相关的其他元素的重要性。</p>
<p>编码器：将输入序列中的每个元素编码成一个向量，并将其添加到全局编码器的状态中。<br>解码器：从全局编码器的状态中读取编码器的输出，然后将其解码为输出序列中的每个元素。<br>注意力机制：计算解码器当前正在处理的元素与全局编码器状态中所有元素之间的注意力关系，然后根据注意力关系对解码器的输出进行加权平均。<br>位置编码：对于每个输入元素，使用预先定义的位置编码来计算其在全局编码器状态中的位置。<br>训练：使用数据集训练模型，并优化模型的参数以最小化损失函数。</p>
<h3><span id="构建神经网络">构建神经网络：</span></h3>
            
        </div>
    </div>
-->
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="color: #00a596">机器学习</a>
        </span>
        
    </div>

<!--
    <span class="icon">
        <i class="fa-solid fa-tags fa-fw"></i>
    </span>

    <span class="date">
        <span class="icon">
            <i class="fa-solid fa-calendar fa-fw"></i>
        </span>
        2024/4/1
    </span>
-->
    <a href="/2024/04/01/pytorch%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/" class="go-post">阅读全文</a>

</div>

<div class="post">
    <a href="/2024/03/31/Java%E5%AE%9E%E7%8E%B0%E4%BA%BA%E6%9C%BA%E5%AF%B9%E6%88%98%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F/">
        <h2 class="post-title">Java实现人机对战五子棋游戏</h2>
    </a>



    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java%E9%A1%B9%E7%9B%AE/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Java项目
            </a>
        </span>

        


        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/31
        </span>



        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
        </div>
    </div>
<!--
    <div class="description">
        <div class="content" v-pre>
            
            <h1><span id="思路很简单就是简单的启发式搜索算法">思路很简单，就是简单的启发式搜索算法。</span></h1><h2><span id="机器端通过对棋盘的打分来计算落子位置">机器端通过对棋盘的“打分”来计算落子位置。</span></h2><pre><code class="java">import java.util.Scanner;
import java.awt.Point;
import java.util.Random;

public class ChessGame &#123;

​    private static final int BOARD_GRAD_SIZE = 15;

​    public class ChessData &#123;
​        int[][] chessMap = new int[BOARD_GRAD_SIZE][BOARD_GRAD_SIZE];
​        int[][] scoreMap = new int[BOARD_GRAD_SIZE][BOARD_GRAD_SIZE];
​        boolean playerFlag;
​    &#125;

​    public class Point &#123;
​        int row;
​        int col;

​        public Point(int row, int col) &#123;
​            this.row = row;
​            this.col = col;
​        &#125;
​    &#125;

​    public void initializeChessData(ChessData data) &#123;
​        if (data == null)
​            return;

​        for (int row = 0; row &lt; BOARD_GRAD_SIZE; row++) &#123;
​            for (int col = 0; col &lt; BOARD_GRAD_SIZE; col++) &#123;
​                data.chessMap[row][col] = 0;
​                data.scoreMap[row][col] = 0;
​            &#125;
​        &#125;
​        data.playerFlag = true;
​    &#125;

​    public void updateGameMap(ChessData data, int row, int col) &#123;
​        if (data == null)
​            return;

​        if (data.playerFlag) &#123;
​            data.chessMap[row][col] = 1;
​        &#125; else &#123;
​            data.chessMap[row][col] = -1;
​        &#125;

​        data.playerFlag = !data.playerFlag;
​    &#125;

​    public boolean checkWin(ChessData game, int row, int col) &#123;
​        for (int i = 0; i &lt; 5; i++) &#123;
​            if (col - i &gt;= 0 &amp;&amp;
​                    col - i + 4 &lt; BOARD_GRAD_SIZE &amp;&amp;
​                    game.chessMap[row][col - i] == game.chessMap[row][col - i + 1] &amp;&amp;
​                    game.chessMap[row][col - i] == game.chessMap[row][col - i + 2] &amp;&amp;
​                    game.chessMap[row][col - i] == game.chessMap[row][col - i + 3] &amp;&amp;
​                    game.chessMap[row][col - i] == game.chessMap[row][col - i + 4]) &#123;
​                return true;
​            &#125;
​        &#125;

​        for (int i = 0; i &lt; 5; i++) &#123;
​            if (row - i &gt;= 0 &amp;&amp;
​                    row - i + 4 &lt; BOARD_GRAD_SIZE &amp;&amp;
​                    game.chessMap[row - i][col] == game.chessMap[row - i + 1][col] &amp;&amp;
​                    game.chessMap[row - i][col] == game.chessMap[row - i + 2][col] &amp;&amp;
​                    game.chessMap[row - i][col] == game.chessMap[row - i + 3][col] &amp;&amp;
​                    game.chessMap[row - i][col] == game.chessMap[row - i + 4][col]) &#123;
​                return true;
​            &#125;
​        &#125;

​        for (int i = 0; i &lt; 5; i++) &#123;
​            if (row + i &lt; BOARD_GRAD_SIZE &amp;&amp;
​                    row + i - 4 &gt;= 0 &amp;&amp;
​                    col - i &gt;= 0 &amp;&amp;
​                    col - i + 4 &lt; BOARD_GRAD_SIZE) &#123;
​                boolean isWin = true;
​                for (int j = 0; j &lt; 5; j++) &#123;
​                    if (game.chessMap[row + i - j][col - i + j] != game.chessMap[row + i][col - i]) &#123;
​                        isWin = false;
​                        break;
​                    &#125;
​                &#125;
​                if (isWin) &#123;
​                    return true;
​                &#125;
​            &#125;
​        &#125;

​        for (int i = 0; i &lt; 5; i++) &#123;
​            if (row - i &gt;= 0 &amp;&amp;
​                    row - i + 4 &lt; BOARD_GRAD_SIZE &amp;&amp;
​                    col - i &gt;= 0 &amp;&amp;
​                    col - i + 4 &lt; BOARD_GRAD_SIZE) &#123;
​                boolean isWin = true;
​                for (int j = 0; j &lt; 5; j++) &#123;
​                    if (game.chessMap[row - i + j][col - i + j] != game.chessMap[row - i][col - i]) &#123;
​                        isWin = false;
​                        break;
​                    &#125;
​                &#125;
​                if (isWin) &#123;
​                    return true;
​                &#125;
​            &#125;
​        &#125;

​        return false;
​    &#125;

​    public Point actionByAI(ChessData data) &#123;
​        calculateScore(data);

​        int maxScore = 0;
​        Point[] maxPoints = new Point[BOARD_GRAD_SIZE * BOARD_GRAD_SIZE];
​        int k = 0;

​        for (int row = 0; row &lt; BOARD_GRAD_SIZE; row++) &#123;
​            for (int col = 0; col &lt; BOARD_GRAD_SIZE; col++) &#123;
​                if (data.chessMap[row][col] == 0) &#123;
​                    if (data.scoreMap[row][col] &gt; maxScore) &#123;
​                        k = 0;
​                        maxScore = data.scoreMap[row][col];
​                        maxPoints[k] = new Point(row, col);
​                        k++;
​                    &#125; else if (data.scoreMap[row][col] == maxScore) &#123;
​                        maxPoints[k] = new Point(row, col);
​                        k++;
​                    &#125;
​                &#125;
​            &#125;
​        &#125;

​        Random rand = new Random();
​        int index = rand.nextInt(k);
​        return maxPoints[index];
​    &#125;

​    public void calculateScore(ChessData data) &#123;
​        int personNum;
​        int botNum;
​        int emptyNum;

​        for (int row = 0; row &lt; BOARD_GRAD_SIZE; row++) &#123;
​            for (int col = 0; col &lt; BOARD_GRAD_SIZE; col++) &#123;
​                if (row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; data.chessMap[row][col] == 0) &#123;
​                    int[][] directs = &#123;
​                            &#123; 1, 0 &#125;,
​                            &#123; 1, 1 &#125;,
​                            &#123; 0, 1 &#125;,
​                            &#123; -1, 1 &#125;
​                    &#125;;

​                    for (int k = 0; k &lt; 4; k++) &#123;
​                        int x = directs[k][0];
​                        int y = directs[k][1];

​                        personNum = 0;
​                        botNum = 0;
​                        emptyNum = 0;

​                        for (int i = 1; i &lt;= 4; i++) &#123;
​                            if (row + i * y &gt;= 0 &amp;&amp; row + i * y &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    col + i * x &gt;= 0 &amp;&amp; col + i * x &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    data.chessMap[row + i * y][col + i * x] == 1) &#123;
​                                personNum++;
​                            &#125; else if (row + i * y &gt;= 0 &amp;&amp; row + i * y &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    col + i * x &gt;= 0 &amp;&amp; col + i * x &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    data.chessMap[row + i * y][col + i * x] == 0) &#123;
​                                emptyNum++;
​                                break;
​                            &#125; else &#123;
​                                break;
​                            &#125;
​                        &#125;

​                        for (int i = 1; i &lt;= 4; i++) &#123;
​                            if (row - i * y &gt;= 0 &amp;&amp; row - i * y &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    col - i * x &gt;= 0 &amp;&amp; col - i * x &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    data.chessMap[row - i * y][col - i * x] == 1) &#123;
​                                personNum++;
​                            &#125; else if (row - i * y &gt;= 0 &amp;&amp; row - i * y &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    col - i * x &gt;= 0 &amp;&amp; col - i * x &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    data.chessMap[row - i * y][col - i * x] == 0) &#123;
​                                emptyNum++;
​                                break;
​                            &#125; else &#123;
​                                break;
​                            &#125;
​                        &#125;

​                        if (personNum == 1) &#123;
​                            data.scoreMap[row][col] += 10;
​                        &#125; else if (personNum == 2) &#123;
​                            if (emptyNum == 1) &#123;
​                                data.scoreMap[row][col] += 30;
​                            &#125; else if (emptyNum == 2) &#123;
​                                data.scoreMap[row][col] += 40;
​                            &#125;
​                        &#125; else if (personNum == 3) &#123;
​                            if (emptyNum == 1) &#123;
​                                data.scoreMap[row][col] += 60;
​                            &#125; else if (emptyNum == 2) &#123;
​                                data.scoreMap[row][col] += 200;
​                            &#125;
​                        &#125; else if (personNum == 4) &#123;
​                            data.scoreMap[row][col] += 20000;
​                        &#125;

​                        emptyNum = 0;

​                        for (int i = 1; i &lt;= 4; i++) &#123;
​                            if (row + i * y &gt; 0 &amp;&amp; row + i * y &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    col + i * x &gt; 0 &amp;&amp; col + i * x &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    data.chessMap[row + i * y][col + i * x] == -1) &#123;
​                                botNum++;
​                            &#125; else if (row + i * y &gt; 0 &amp;&amp; row + i * y &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    col + i * x &gt; 0 &amp;&amp; col + i * x &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    data.chessMap[row + i * y][col + i * x] == 0) &#123;
​                                emptyNum++;
​                                break;
​                            &#125; else &#123;
​                                break;
​                            &#125;
​                        &#125;

​                        for (int i = 1; i &lt;= 4; i++) &#123;
​                            if (row - i * y &gt; 0 &amp;&amp; row - i * y &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    col - i * x &gt; 0 &amp;&amp; col - i * x &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    data.chessMap[row - i * y][col - i * x] == -1) &#123;
​                                botNum++;
​                            &#125; else if (row - i * y &gt; 0 &amp;&amp; row - i * y &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    col - i * x &gt; 0 &amp;&amp; col - i * x &lt; BOARD_GRAD_SIZE &amp;&amp;
​                                    data.chessMap[row - i * y][col - i * x] == 0) &#123;
​                                emptyNum++;
​                                break;
​                            &#125; else &#123;
​                                break;
​                            &#125;
​                        &#125;

​                        if (botNum == 0) &#123;
​                            data.scoreMap[row][col] += 5;
​                        &#125; else if (botNum == 1) &#123;
​                            data.scoreMap[row][col] += 10;
​                        &#125; else if (botNum == 2) &#123;
​                            if (emptyNum == 1) &#123;
​                                data.scoreMap[row][col] += 25;
​                            &#125; else if (emptyNum == 2) &#123;
​                                data.scoreMap[row][col] += 50;
​                            &#125;
​                        &#125; else if (botNum == 3) &#123;
​                            if (emptyNum == 1) &#123;
​                                data.scoreMap[row][col] += 55;
​                            &#125; else if (emptyNum == 2) &#123;
​                                data.scoreMap[row][col] += 300;
​                            &#125;
​                        &#125; else if (botNum &gt;= 4) &#123;
​                            data.scoreMap[row][col] += 30000;
​                        &#125;
​                    &#125;
​                &#125;
​            &#125;
​        &#125;
​    &#125;

​    public static void main(String[] args) &#123;
​        ChessGame game = new ChessGame();
​        ChessData data = game.new ChessData();
​        game.initializeChessData(data);

​        Scanner scanner = new Scanner(System.in);

​        // 游戏主循环
​        while (true) &#123;
​            Point point = game.actionByAI(data);
​            System.out.println(&quot;AI选择下在这里: (&quot; + point.row + &quot;, &quot; + point.col + &quot;)&quot;);
​            game.updateGameMap(data, point.row, point.col);
​            if (game.checkWin(data, point.row, point.col)) &#123;
​                System.out.println(&quot;对不起，你输了，AI获胜&quot;);
​                break;
​            &#125;

​            // 玩家输入逻辑
​            System.out.println(&quot;轮到你下了，请输入坐标 (例如, &#39;3 4&#39;): &quot;);
​            int playerRow = scanner.nextInt();
​            int playerCol = scanner.nextInt();

​            if (playerRow &lt; 0 || playerRow &gt;= BOARD_GRAD_SIZE || playerCol &lt; 0 || playerCol &gt;= BOARD_GRAD_SIZE) &#123;
​                System.out.println(&quot;你不能下在这里，请重新输入！&quot;);
​                continue;
​            &#125;

​            if (data.chessMap[playerRow][playerCol] != 0) &#123;
​                System.out.println(&quot;你不能下在这里，这里已经有棋子了，下在其他地方吧&quot;);
​                continue;
​            &#125;

​            game.updateGameMap(data, playerRow, playerCol);
​            if (game.checkWin(data, playerRow, playerCol)) &#123;
​                System.out.println(&quot;恭喜你赢了！&quot;);
​                break;
​            &#125;

​            // 打印棋盘状态
​            printChessboard(data);
​        &#125;
​    &#125;

​    // 打印棋盘状态
​    private static void printChessboard(ChessData data) &#123;
​        for (int row = 0; row &lt; BOARD_GRAD_SIZE; row++) &#123;
​            for (int col = 0; col &lt; BOARD_GRAD_SIZE; col++) &#123;
​                if (data.chessMap[row][col] == 1) &#123;
​                    System.out.print(&quot;X &quot;);
​                &#125; else if (data.chessMap[row][col] == -1) &#123;
​                    System.out.print(&quot;O &quot;);
​                &#125; else &#123;
​                    System.out.print(&quot;. &quot;);
​                &#125;
​            &#125;
​            System.out.println();
​        &#125;
​    &#125;
&#125;

</code></pre>

            
        </div>
    </div>
-->
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Java/" style="color: #ffa2c4">Java</a>
        </span>
        
    </div>

<!--
    <span class="icon">
        <i class="fa-solid fa-tags fa-fw"></i>
    </span>

    <span class="date">
        <span class="icon">
            <i class="fa-solid fa-calendar fa-fw"></i>
        </span>
        2024/3/31
    </span>
-->
    <a href="/2024/03/31/Java%E5%AE%9E%E7%8E%B0%E4%BA%BA%E6%9C%BA%E5%AF%B9%E6%88%98%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F/" class="go-post">阅读全文</a>

</div>

<div class="post">
    <a href="/2024/03/31/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
        <h2 class="post-title">Python学习笔记</h2>
    </a>



    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                基础知识
            </a>
        </span>

        


        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/31
        </span>



        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
        </div>
    </div>
<!--
    <div class="description">
        <div class="content" v-pre>
            
            <h1><span id="python">Python</span></h1><p>[TOC]</p>
<h2><span id="一编程前的准备工作">一.编程前的准备工作</span></h2><p>在命令行（bash）中打开 Python 和运行 Python 文件的步骤如下：</p>
<h3><span id="1-打开-python-解释器">1. 打开 Python 解释器</span></h3><p>在命令行中输入以下命令并按回车键：</p>
<pre><code>python
</code></pre>
<p>这将启动 Python 解释器，你将看到一个提示符 <code>&gt;&gt;&gt;</code>，表示你可以在这里输入 Python 代码并执行。</p>
<h3><span id="2-运行-python-文件">2. 运行 Python 文件</span></h3><p>在命令提示符（cmd.exe）中，你无需输入 <code>python</code> 或 <code>python3</code>，而是直接输入以下命令：</p>
<pre><code>test.py
</code></pre>
<p>确保你的命令提示符的当前工作目录是包含 <code>test.py</code> 文件的目录，或者你可以提供文件的完整路径。这样应该可以成功运行 <code>test.py</code> 文件。</p>
<p>可以使用 <code>cd</code> 命令切换到包含 <code>test.py</code> 文件的目录，然后再运行 <code>test.py</code>。例如：</p>
<pre><code>cd path\to\your\script\directory
test.py
</code></pre>
<p>这里的 <code>path\to\your\script\directory</code> 是包含 <code>test.py</code> 文件的目录的路径。</p>
<p>如果你知道 <code>test.py</code> 文件的绝对路径，也可以直接在命令提示符中输入：</p>
<pre><code>path\to\test.py
</code></pre>
<h2><span id="二python的语言基础">二.Python的语言基础</span></h2><h3><span id="1type函数">1.type()函数：</span></h3><p>在交互模式下得到参数的数据类型</p>
<h3><span id="2-乘方-幂运算">2. 乘方 ，幂运算</span></h3><h3><span id="3eval函数">3.eval()函数：</span></h3><p><code>eval()</code> 函数是一个内置函数，它用于动态地执行字符串表达式，并返回表达式的结果。这个函数接受一个字符串参数，该字符串包含有效的Python表达式，然后执行该表达式并返回结果。</p>
<p>语法：</p>
<pre><code class="python">eval(expression, globals=None, locals=None)
</code></pre>
<ul>
<li><code>expression</code>: 要执行的字符串表达式。</li>
<li><code>globals</code>（可选）: 一个字典，用于全局命名空间的变量。如果提供了 <code>globals</code> 参数，那么 <code>eval()</code> 函数将在这个字典的上下文中执行表达式。</li>
<li><code>locals</code>（可选）: 一个字典，用于局部命名空间的变量。如果提供了 <code>locals</code> 参数，那么 <code>eval()</code> 函数将在这个字典的上下文中执行表达式。</li>
</ul>
<p>使用 <code>eval()</code> 的例子：</p>
<pre><code class="python">x = 10
y = 20
result = eval(&#39;x + y&#39;)
print(result)  # 输出 30
</code></pre>
<p>在这个例子中，<code>eval(&#39;x + y&#39;)</code> 执行了字符串表达式 <code>&#39;x + y&#39;</code>，并返回结果 <code>30</code>。</p>
<p>需要注意的是，<code>eval()</code> 函数具有潜在的安全风险，因为它允许执行任意的Python代码。如果从不受信任的来源获取字符串并将其传递给 <code>eval()</code>，可能会导致安全问题。因此，应该谨慎使用 <code>eval()</code>，特别是在处理用户输入时。</p>
<h3><span id="4input函数">4.input()函数：</span></h3><p>获取用户输入的数据，input() 内可以放双引号””来添加内容。</p>
<h3><span id="5格式化字符串format">5.格式化字符串format():</span></h3><p><code>format()</code> 方法是用于格式化字符串的内置方法。它允许你通过将占位符 <code>&#123;&#125;</code> 插入字符串中，并使用 <code>format()</code> 方法提供的参数替换这些占位符。</p>
<p>基本的语法如下：</p>
<pre><code class="python">formatted_string = &quot;Some text with &#123;&#125; and &#123;&#125;&quot;.format(value1, value2)
</code></pre>
<p>这里的 <code>&#123;&#125;</code> 是占位符，它们会依次被 <code>format()</code> 方法的参数替换。可以有多个占位符，也可以使用序号或关键字来指定替换的值。</p>
<p>例子：</p>
<pre><code class="python">name = &quot;John&quot;
age = 30
# 使用位置参数
formatted_string = &quot;My name is &#123;&#125; and I am &#123;&#125; years old.&quot;.format(name, age)
print(formatted_string)
# 输出: My name is John and I am 30 years old.
</code></pre>
<pre><code class="python"># 使用序号指定顺序
formatted_string = &quot;&#123;1&#125; is &#123;0&#125; years old.&quot;.format(age, name)
print(formatted_string)
# 输出: John is 30 years old.
</code></pre>
<pre><code class="python"># 使用关键字参数
formatted_string = &quot;My name is &#123;n&#125; and I am &#123;a&#125; years old.&quot;.format(n=name, a=age)
print(formatted_string)
# 输出: My name is John and I am 30 years old.
</code></pre>
<p><code>format()</code> 方法还支持更复杂的格式设置，包括指定字段宽度、精度、填充字符等。以下是一个简单的例子：</p>
<pre><code class="python">pi = 3.1415926535

# 指定小数点后两位
formatted_string = &quot;The value of pi is &#123;:.2f&#125;&quot;.format(pi)
print(formatted_string)
# 输出: The value of pi is 3.14
</code></pre>
<p>这些只是 <code>format()</code> 方法的一些基础用法，详细的格式化选项可以查阅 Python 官方文档。</p>
<h3><span id="6续行符号">6.续行符号\</span></h3><pre><code class="python">print(&quot;我是一名程序员\
我刚开始学习python&quot;)
</code></pre>
<h3><span id="7print函数">7.print()函数</span></h3><pre><code class="python">for i in range(1, 10):
    for j in range(1, i+1):
        product = i * j
        print(f&quot;&#123;j&#125; * &#123;i&#125; = &#123;product&#125;\t&quot;, end=&quot;&quot;)
    print()
</code></pre>
<h4><span id="1默认换行">（1）默认换行</span></h4><p><strong>在Python中，<code>print()</code> 函数默认在打印完内容之后会添加一个换行符（<code>\n</code>）</strong>，从而使下一个输出跳到新的一行。这是因为在Python 3中，<code>print()</code> 函数有一个默认的 <code>end</code> 参数，其默认值为 <code>\n</code>，表示在输出结束时要添加的字符串。</p>
<p>例如：</p>
<pre><code class="python">print(&quot;Hello&quot;)
print(&quot;World&quot;)
</code></pre>
<p>这段代码的输出将是：</p>
<pre><code>Hello
World
</code></pre>
<p>如果你想自定义 <code>end</code> 参数，可以在 <code>print()</code> 函数中指定，比如：</p>
<pre><code class="python">print(&quot;Hello&quot;, end=&quot;***&quot;)
print(&quot;World&quot;)
</code></pre>
<p>这样的输出将是：</p>
<pre><code>Hello***World
</code></pre>
<p>但通常情况下，我们使用 <code>print()</code> 函数时不需要显式指定 <code>end</code> 参数，因为默认的换行符对于大多数情况都是合适的。</p>
<h4><span id="2格式化输出">（2）格式化输出</span></h4><p>在这个语句中，<code>f&quot;&#123;j&#125; * &#123;i&#125; = &#123;product&#125;\t&quot;</code> 使用了 f-string（格式化字符串字面值）。f-string 是在 Python 3.6 版本中引入的一种方便的字符串格式化方式。</p>
<p>在一个 f-string 中，你可以在字符串中嵌入表达式，这些表达式会在运行时被求值，并将结果插入到字符串中。在这里，<code>&#123;j&#125;</code>, <code>&#123;i&#125;</code>, <code>&#123;product&#125;</code> 都是表达式，分别代表变量 <code>j</code>、<code>i</code> 和 <code>product</code> 的值。<code>\t</code> 表示制表符，用于在输出中产生水平间距。</p>
<p>这样的语法使得字符串的构建更加清晰和简便，而不需要使用传统的字符串连接方式。例子中的 f-string 被用于构建乘法口诀表中每行的输出。</p>
<h2><span id="三小海龟turtle">三.小海龟Turtle</span></h2><h3><span id="1基本操作">1.基本操作</span></h3><pre><code class="python">import turtle
turtle.forward(200)
turtle.done() #结束绘制工作
turtle.left(90) #向左旋转90度
turtle.color(&quot;red&quot;)
#上色：
turtle.color(&quot;yellow&quot;)
turtle.begin_fill()
turtle.end_fill()
#背景
turtle.bgcolor(&quot;black&quot;)
#移动开始位置
turtle.up()
turtle.goto(100,100)
turtle.down()
</code></pre>
<h3><span id="2循环">2.循环</span></h3><pre><code class="python">for i in range(4): #先记住
    turtle.forward(200)
    turtle.left(90)
</code></pre>
<h2><span id="四程序的流程控制">四，程序的流程控制</span></h2><h3><span id="1基本内容">1.基本内容</span></h3><p>if else</p>
<p>elif</p>
<p>while</p>
<p>for</p>
<h3><span id="2循环中的else">2.循环中的else</span></h3><p>python中特有，循环中可以有else分支</p>
<p>可以使用while或者for</p>
<pre><code class="python">str = input()
for letter in str:
    print(letter,end = &quot; &quot;)
else:
    print(&quot;循环正常结束&quot;)
print(&quot;程序结束&quot;)
</code></pre>
<h2><span id="五函数与模块">五，函数与模块</span></h2><h3><span id="1匿名函数">1.匿名函数</span></h3><p>仅包含一条语句，参数可有可无，参数个数任意</p>
<pre><code class="python">s = lambda : &quot;python&quot;.upper()
f = lambda x : x*10
print(s())
print(f(10))
</code></pre>
<h3><span id="2默认参数与关键字参数">2.默认参数与关键字参数</span></h3><p>在Python中，函数的参数可以分为两种：默认参数和关键字参数。</p>
<ol>
<li><p><strong>默认参数（Default Parameters）：</strong></p>
<p>默认参数是在定义函数时给参数一个默认值，如果在调用函数时没有传递该参数，则使用默认值。定义默认参数的语法是在函数定义中给参数赋予默认值。</p>
<p>示例：</p>
<pre><code class="python">def greet(name, greeting=&quot;Hello&quot;):
    print(f&quot;&#123;greeting&#125;, &#123;name&#125;!&quot;)

greet(&quot;Alice&quot;)  # 使用默认值输出：Hello, Alice!
greet(&quot;Bob&quot;, &quot;Good morning&quot;)  # 使用传递的值输出：Good morning, Bob!
</code></pre>
<p>在这个例子中，<code>greeting</code> 参数有一个默认值 “Hello”，如果不提供该参数，将使用默认值。</p>
</li>
<li><p><strong>关键字参数（Keyword Arguments）：</strong></p>
<p>关键字参数是通过指定参数名进行传递的参数。在函数调用中，通过 <code>parameter_name=value</code> 的形式传递参数，这样可以不按照函数定义时的参数顺序传递。</p>
<p>示例：</p>
<pre><code class="python">def display_info(name, age, city):
    print(f&quot;Name: &#123;name&#125;, Age: &#123;age&#125;, City: &#123;city&#125;&quot;)

display_info(age=25, name=&quot;Alice&quot;, city=&quot;Wonderland&quot;)
</code></pre>
<p>在这个例子中，通过关键字参数指定了参数的值，顺序可以与函数定义时不同。</p>
</li>
</ol>
<p>注意事项：</p>
<ul>
<li>默认参数必须在非默认参数之后定义，例如 <code>def func(param1, param2=default_value):</code>。</li>
<li>如果同时使用默认参数和关键字参数，关键字参数必须位于默认参数之后。</li>
</ul>
<h3><span id="3不定长参数">3.不定长参数</span></h3><p>在Python中，有两种不定长参数的方式：可变位置参数和可变关键字参数。</p>
<ol>
<li><p><strong>可变位置参数（*args）：</strong></p>
<p>可变位置参数允许你传递任意数量的位置参数给函数。在函数定义时，在参数前面加上 <code>*</code> 号，这表示接受任意数量的位置参数，并将它们作为元组传递给函数。</p>
<p>示例：</p>
<pre><code class="python">def print_args(*args):
    for arg in args:
        print(arg)

print_args(1, 2, 3, &quot;four&quot;)
</code></pre>
<p>这个函数接受任意数量的参数，并将它们打印出来。</p>
</li>
<li><p><strong>可变关键字参数（</strong>kwargs）：**</p>
<p>可变关键字参数允许你传递任意数量的关键字参数给函数。在函数定义时，在参数前面加上 <code>**</code> 号，这表示接受任意数量的关键字参数，并将它们作为字典传递给函数。</p>
<p>示例：</p>
<pre><code class="python">def print_kwargs(**kwargs):
    for key, value in kwargs.items():
        print(f&quot;&#123;key&#125;: &#123;value&#125;&quot;)

print_kwargs(name=&quot;Alice&quot;, age=25, city=&quot;Wonderland&quot;)
</code></pre>
<p>这个函数接受任意数量的关键字参数，并将它们打印出来。</p>
</li>
</ol>
<p>使用时，你可以同时使用这两种不定长参数，例如：</p>
<pre><code class="python">def example_function(arg1, *args, kwarg1=&quot;default&quot;, **kwargs):
    # 函数体
    pass
</code></pre>
<p>这个函数可以接受一个位置参数 <code>arg1</code>，任意数量的位置参数 <code>args</code>，一个默认值的关键字参数 <code>kwarg1</code>，和任意数量的关键字参数 <code>kwargs</code>。</p>
<h3><span id="4模块化程序设计">4.模块化程序设计</span></h3><h4><span id="1基础知识">(1)基础知识</span></h4><p>一个或几个.py相关的函数保存为.py文件，构成一个模块，导入该模块，可以调用模块中定义的函数</p>
<p>在Python中，你可以将几个不同的函数打包为一个模块。以下是一个简单的步骤：</p>
<ol>
<li><p><strong>创建一个新的Python文件：</strong> 为你的模块选择一个名称，并创建一个以<code>.py</code>为扩展名的新文件，例如<code>mymodule.py</code>。</p>
</li>
<li><p><strong>在文件中定义函数：</strong> 在新文件中，定义你想要包含的函数。例如：</p>
<pre><code class="python"># mymodule.py

def add_numbers(a, b):
    return a + b

def multiply_numbers(a, b):
    return a * b

def greet(name):
    return f&quot;Hello, &#123;name&#125;!&quot;
</code></pre>
</li>
<li><p><strong>保存文件：</strong> 保存你的文件。</p>
</li>
<li><p><strong>在其他Python文件中使用模块：</strong> 你可以在其他Python文件中使用你创建的模块。例如，如果你的模块文件和使用模块的文件在同一目录下，可以这样使用：</p>
<pre><code class="python"># 使用模块的文件
  
import mymodule
  
result = mymodule.add_numbers(3, 4)
print(result)
  
greeting = mymodule.greet(&quot;John&quot;)
print(greeting)
</code></pre>
<p>如果模块文件不在同一目录下，你可以将模块文件所在的路径添加到Python解释器的搜索路径中，或者使用相对路径导入模块。</p>
</li>
</ol>
<p>通过这种方式，你可以将多个函数组织在一个模块中，使代码更易于管理和维护。</p>
<p>如果模块文件不在同一目录下，你可以使用以下方法导入模块：</p>
<p>假设有以下目录结构：</p>
<pre><code>project/
|-- modules/
|   |-- mymodule.py
|-- main.py
</code></pre>
<ol>
<li><p><strong>添加模块所在路径到sys.path：</strong></p>
<p>在<code>main.py</code>文件中，你可以使用<code>sys.path</code>添加模块所在的路径。确保你的<code>main.py</code>文件中包含以下代码：</p>
<pre><code class="python"># main.py

import sys
sys.path.append(&quot;path/to/modules&quot;)

import mymodule

result = mymodule.add_numbers(3, 4)
print(result)

greeting = mymodule.greet(&quot;John&quot;)
print(greeting)
</code></pre>
<p>将<code>&quot;path/to/modules&quot;</code>替换为<code>mymodule.py</code>所在的实际路径。</p>
</li>
<li><p><strong>使用相对路径导入：</strong></p>
<p>如果<code>main.py</code>和<code>mymodule.py</code>在相对位置上有固定的相对路径，你可以使用相对导入。例如，如果<code>main.py</code>和<code>mymodule.py</code>在同一目录下，可以这样导入：</p>
<pre><code class="python"># main.py

from modules import mymodule

result = mymodule.add_numbers(3, 4)
print(result)

greeting = mymodule.greet(&quot;John&quot;)
print(greeting)
</code></pre>
<p>如果<code>main.py</code>在<code>project</code>目录下，你可以使用<code>from modules import mymodule</code>。</p>
</li>
</ol>
<p>选择适合你项目结构的方法，并确保你正确引入了模块。</p>
<h4><span id="2模块及其引用">(2)模块及其引用</span></h4><p>在Python中，有几种不同的模块引用方法，具体取决于模块的位置和你希望如何引用它。以下是一些常见的模块引用方法：</p>
<ol>
<li><p><strong>绝对路径引用：</strong></p>
<p>如果模块在Python解释器的搜索路径中，你可以使用绝对路径引用。这是最基本的引用方式。</p>
<pre><code class="python"># 使用绝对路径引用
import mymodule
</code></pre>
</li>
<li><p><strong>相对路径引用：</strong></p>
<p>如果你的模块和使用它的脚本在相同目录下或有固定的相对路径关系，可以使用相对路径引用。</p>
<pre><code class="python"># 使用相对路径引用
from . import mymodule  # 当脚本和模块在同一目录下
</code></pre>
</li>
<li><p><strong>添加路径到sys.path：</strong></p>
<p>通过将模块所在路径添加到<code>sys.path</code>，你可以使用绝对或相对引用。</p>
<pre><code class="python"># 添加路径到sys.path
import sys
sys.path.append(&quot;path/to/modules&quot;)

import mymodule
</code></pre>
</li>
<li><p><strong>包引用：</strong></p>
<p>如果你的模块在一个包（目录）中，你可以使用包引用。</p>
<pre><code class="python"># 包引用
from mypackage import mymodule
</code></pre>
<p>这假设<code>mymodule</code>是<code>mypackage</code>包中的一个模块。</p>
</li>
<li><p><strong>别名引用：</strong></p>
<p>你还可以为模块使用别名，使代码更简洁。</p>
<pre><code class="python"># 使用别名引用
import mymodule as mm
</code></pre>
<p>然后，你可以使用 <code>mm</code> 来代替 <code>mymodule</code>。</p>
</li>
</ol>
<p>选择适合你项目结构和需求的引用方法，并确保你的模块路径正确。</p>
<p>在Python中，<code>sys.path</code>是一个包含用于查找模块的目录路径的列表。这个列表由解释器在启动时设置，它包括了以下几个元素：</p>
<ol>
<li>当前工作目录（Current Working Directory）。</li>
<li>PYTHONPATH 环境变量中指定的目录。</li>
<li>内置模块的默认路径。</li>
<li>在安装 Python 时配置的默认路径。</li>
</ol>
<p><code>sys.path</code>中的目录路径按照它们在列表中的顺序进行搜索。当你导入一个模块时，Python 解释器会按照这个路径列表的顺序在这些目录中查找相应的模块文件。</p>
<p>你可以通过在代码中修改 <code>sys.path</code> 来添加或删除目录路径，以影响模块的搜索路径。例如，你可以使用 <code>sys.path.append(&quot;path/to/directory&quot;)</code> 将目录添加到搜索路径中。</p>
<p>以下是一个简单的示例，演示了 <code>sys.path</code> 的基本用法：</p>
<pre><code class="python">import sys

# 输出当前 sys.path
print(&quot;Current sys.path:&quot;, sys.path)

# 添加一个目录到 sys.path
sys.path.append(&quot;/path/to/custom/directory&quot;)

# 再次输出 sys.path
print(&quot;Updated sys.path:&quot;, sys.path)
</code></pre>
<p>通过了解 <code>sys.path</code>，你可以更好地理解 Python 解释器在哪里查找模块文件。这对于处理模块的导入和路径问题非常有用。</p>
<h4><span id="3包">(3)包</span></h4><p>在Python中，包（Package）是一种将模块组织在一起的方式，以便更好地管理和组织代码。包本质上是一个包含了特殊文件 <code>__init__.py</code> 的目录，该目录下可以包含其他模块或子包。</p>
<p>以下是创建和引用Python包的基本步骤：</p>
<h3><span id="建立包">建立包：</span></h3><ol>
<li><p><strong>创建包目录：</strong> 创建一个目录，该目录将作为包的顶级目录。</p>
<pre><code>mypackage/
</code></pre>
</li>
<li><p><strong>在包目录中添加 <code>__init__.py</code> 文件：</strong> 添加一个空的 <code>__init__.py</code> 文件，它会告诉Python这个目录应该被视为一个包。</p>
<pre><code>mypackage/
├── __init__.py
</code></pre>
</li>
<li><p><strong>在包中添加模块文件：</strong> 在包目录中添加模块文件，可以是以<code>.py</code>为扩展名的Python文件。</p>
<pre><code>mypackage/
├── __init__.py
├── module1.py
├── module2.py
</code></pre>
<pre><code class="python"># module1.py
def function1():
    print(&quot;Function 1 in module1&quot;)

# module2.py
def function2():
    print(&quot;Function 2 in module2&quot;)
</code></pre>
</li>
</ol>
<h3><span id="引用包中的模块">引用包中的模块：</span></h3><ol>
<li><p><strong>绝对路径引用：</strong> 使用绝对路径引用包中的模块。</p>
<pre><code class="python"># main.py
from mypackage import module1, module2

module1.function1()
module2.function2()
</code></pre>
</li>
<li><p><strong>相对路径引用：</strong> 在包内的模块之间进行相对路径引用。</p>
<pre><code class="python"># module1.py
from .module2 import function2

def function1():
    print(&quot;Function 1 in module1&quot;)
    function2()
</code></pre>
</li>
<li><p><strong>导入整个包：</strong> 你也可以导入整个包，然后使用点符号访问模块。</p>
<pre><code class="python"># main.py
import mypackage

mypackage.module1.function1()
mypackage.module2.function2()
</code></pre>
</li>
</ol>
<p>通过这些步骤，你可以创建和引用Python包，从而更好地组织和管理你的代码。</p>
<h4><span id="4内置函数">(4)内置函数</span></h4><p>Python 3中有许多内置函数，这些函数不需要导入任何模块即可使用。以下是一些常用的Python 3内置函数：</p>
<ol>
<li><p><strong>类型转换函数：</strong></p>
<ul>
<li><code>int(x [, base])</code>: 将x转换为一个整数。<code>base</code> 参数指定 x 中的数字是什么进制，默认是十进制。</li>
<li><code>float(x)</code>: 将 x 转换为一个浮点数。</li>
<li><code>str(x)</code>: 将对象 x 转换为字符串。</li>
</ul>
</li>
<li><p><strong>序列操作函数：</strong></p>
<ul>
<li><code>len(sequence)</code>: 返回序列的长度。</li>
<li><code>max(iterable, *[, key, default])</code>: 返回可迭代对象中的最大值。</li>
<li><code>min(iterable, *[, key, default])</code>: 返回可迭代对象中的最小值.</li>
<li><code>sum(iterable, /, start=0)</code>: 返回可迭代对象中所有元素的总和。</li>
</ul>
</li>
<li><p><strong>迭代器和生成器函数：</strong></p>
<ul>
<li><code>iter(object[, sentinel])</code>: 返回一个迭代器对象。</li>
<li><code>next(iterator[, default])</code>: 从迭代器中获取下一个元素。</li>
<li><code>range(stop)</code>, <code>range(start, stop[, step])</code>: 创建一个范围内的数字序列。</li>
</ul>
</li>
<li><p><strong>其他常用函数：</strong></p>
<ul>
<li><code>print(*objects, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</code>: 打印输出。</li>
<li><code>input([prompt])</code>: 从用户获取输入。</li>
<li><code>type(object)</code>: 返回对象的类型。</li>
<li><code>len(object)</code>: 返回对象的长度。</li>
</ul>
</li>
<li><p><strong>数学函数：</strong></p>
<ul>
<li><code>abs(x)</code>: 返回 x 的绝对值。</li>
<li><code>pow(x, y[, z])</code>: 返回 x 的 y 次方，如果给定 z 参数，返回 x 的 y 次方与 z 取模的结果。</li>
</ul>
</li>
</ol>
<p>以上仅是一小部分Python 3内置函数，实际上Python提供了很多有用的内置函数。你可以查阅官方文档或使用 <code>help()</code> 函数来获取更多关于内置函数的信息。</p>
<h2><span id="六数据结构">六，数据结构</span></h2><h3><span id="1元组">1.元组</span></h3><p>就是只读列表</p>
<p>用（）来表示</p>
<p>在Python中，元组是不可变的数据结构，这意味着一旦创建，就不能对其进行修改。因此，删除元组的操作实际上是删除整个元组对象的引用。你不能删除元组中的单个元素，但可以删除整个元组变量。</p>
<p>删除整个元组变量：</p>
<p>使用 <code>del</code> 关键字可以删除整个元组变量。</p>
<pre><code class="python">my_tuple = (1, 2, 3, 4, 5)

# 删除整个元组变量
del my_tuple

# 尝试访问已删除的元组会引发异常
# print(my_tuple)  # 这行代码会引发 NameError
</code></pre>
<p>在上述示例中，<code>del my_tuple</code> 删除了整个元组对象。</p>
<p>删除元组中的元素（不可行）：</p>
<p>由于元组是不可变的，不能删除元组中的单个元素。如果需要删除某个元素，你可能需要考虑使用其他数据结构，如列表（list）。</p>
<pre><code class="python">my_list = [1, 2, 3, 4, 5]

# 删除列表中的元素
del my_list[2]

print(my_list)  # 输出: [1, 2, 4, 5]
</code></pre>
<p>总的来说，元组是不可变的，因此不能直接删除其中的元素。你只能删除整个元组变量。如果你需要对元素进行增删操作，可能需要使用列表等可变的数据结构。</p>
<h3><span id="2列表">2.列表</span></h3><p>列表中可以存放多个元素的值，可以修改或者删除</p>
<p>在Python中，列表（List）是一种可变的数据结构，允许你在创建后对其进行修改。以下是一些常用的列表数据操作方法：</p>
<h4><span id="创建列表">创建列表：</span></h4><pre><code class="python">my_list = [1, 2, 3, 4, 5]
</code></pre>
<h4><span id="访问元素">访问元素：</span></h4><pre><code class="python"># 访问单个元素
first_element = my_list[0]

# 访问多个元素（切片）
subset = my_list[1:4]  # 包含索引 1、2、3的元素
</code></pre>
<h4><span id="修改元素">修改元素：</span></h4><pre><code class="python"># 修改单个元素
my_list[2] = 10

# 修改多个元素（切片赋值）
my_list[1:4] = [20, 30, 40]
</code></pre>
<h4><span id="添加元素">添加元素：</span></h4><pre><code class="python"># 在末尾添加一个元素
my_list.append(6)

# 在指定位置插入一个元素
my_list.insert(2, 15)
</code></pre>
<h4><span id="删除元素">删除元素：</span></h4><pre><code class="python"># 删除指定位置的元素
del my_list[2]

# 删除指定值的第一个匹配项
my_list.remove(30)

# 弹出（删除并返回）指定位置的元素
popped_element = my_list.pop(1)
</code></pre>
<h4><span id="查找元素">查找元素：</span></h4><pre><code class="python"># 查找元素的索引
index = my_list.index(4)
</code></pre>
<h4><span id="其他常用方法">其他常用方法：</span></h4><pre><code class="python"># 获取列表长度
length = len(my_list)

# 排序列表（原地排序）
my_list.sort()

# 反向排序列表（原地操作）
my_list.reverse()

# 复制列表
copy_of_list = my_list.copy()

# 清空列表
my_list.clear()
</code></pre>
<p>以上是一些基本的列表数据操作方法。列表提供了很多灵活的操作，使得对数据的处理变得非常方便。</p>
<p>列表中的pop操作默认删除列表的最后一个元素</p>
<pre><code class="python">number = [1,2,3]
number.pop()
</code></pre>
<p>remove方法移除列表中的某个元素的第一个匹配项</p>
<pre><code>char.remove(&quot;d&quot;)
</code></pre>
<h3><span id="3字符串">3.字符串</span></h3><h4><span id="字符串的截取">字符串的截取</span></h4><pre><code class="python">var = &quot;hello&quot;
var[0]
#得到的结果是h
</code></pre>
<h4><span id="连接字符串">连接字符串</span></h4><pre><code class="python">var1 = &#39;hello&#39;
var2 = &#39;python&#39;
var1 = var1 + var2
print(var1)
#hellopython
</code></pre>
<h4><span id="格式化字符串">格式化字符串</span></h4><p>在Python中，格式化字符串是一种方便的方法，用于创建包含变量或表达式值的字符串。主要有以下几种方式：</p>
<ol>
<li><p><strong>百分比（%）格式化</strong>：这是一种较早的格式化方式。它使用 <code>%</code> 操作符和一个格式字符串。</p>
<pre><code class="python">name = &quot;Alice&quot;
age = 30
formatted_string = &quot;Hello, %s. You are %d years old.&quot; % (name, age)
</code></pre>
</li>
<li><p><strong><code>str.format()</code> 方法</strong>：这是一种更现代的格式化方法，提供了更多的灵活性。</p>
<pre><code class="python">name = &quot;Alice&quot;
age = 30
formatted_string = &quot;Hello, &#123;&#125;. You are &#123;&#125; years old.&quot;.format(name, age)
</code></pre>
<p>你也可以使用索引或关键字来更明确地指定格式化值的位置：</p>
<pre><code class="python">formatted_string = &quot;Hello, &#123;1&#125;. You are &#123;0&#125; years old.&quot;.format(age, name)
</code></pre>
</li>
<li><p><strong>f-字符串（自Python 3.6起可用）</strong>：这是最新且通常最推荐的格式化方法。它非常直观和易读。</p>
<pre><code class="python">name = &quot;Alice&quot;
age = 30
formatted_string = f&quot;Hello, &#123;name&#125;. You are &#123;age&#125; years old.&quot;
</code></pre>
</li>
</ol>
<p>在这些方法中，f-字符串因其简洁和直观而成为许多Python开发者的首选。它允许直接在字符串中插入变量和表达式。</p>
<h4><span id="字符串的操作方法">字符串的操作方法</span></h4><p>在Python中，<code>find()</code> 和 <code>join()</code> 是字符串操作的两个常用方法。</p>
<ol>
<li><p><strong><code>find()</code> 方法：</strong></p>
<ul>
<li><code>find()</code> 方法用于在字符串中查找子字符串，并返回第一个匹配的位置。如果找不到匹配的子字符串，则返回 -1。</li>
<li>语法：<code>str.find(sub[, start[, end]])</code><ul>
<li><code>sub</code> 是要查找的子字符串。</li>
<li><code>start</code> 是可选参数，指定开始查找的位置，默认为 0。</li>
<li><code>end</code> 是可选参数，指定结束查找的位置，默认为字符串的长度。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="python">sentence = &quot;Hello, how are you?&quot;
position = sentence.find(&quot;how&quot;)
print(position)  # 输出: 7
</code></pre>
</li>
<li><p><strong><code>join()</code> 方法：</strong></p>
<ul>
<li><code>join()</code> 方法用于将序列中的元素以指定的字符串连接生成一个新的字符串。</li>
<li>语法：<code>str.join(iterable)</code><ul>
<li><code>str</code> 是连接的字符串。</li>
<li><code>iterable</code> 是一个可迭代对象，如列表、元组等。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="python">words = [&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;]
result = &quot; &quot;.join(words)
print(result)  # 输出: Hello world !
</code></pre>
</li>
</ol>
<p>这两个方法在处理字符串时非常实用。<code>find()</code> 用于查找子字符串的位置，而 <code>join()</code> 用于将多个字符串连接在一起。</p>
<p>在Python中，<code>split()</code> 和 <code>strip()</code> 是两个用于字符串操作的常用方法。</p>
<ol>
<li><p><strong><code>split()</code> 方法：</strong></p>
<ul>
<li><code>split()</code> 方法用于将字符串分割成一个列表，通过指定分隔符。默认情况下，它使用空格作为分隔符。</li>
<li>语法：<code>str.split([sep[, maxsplit]])</code><ul>
<li><code>sep</code> 是可选参数，指定分隔符，默认为空格。</li>
<li><code>maxsplit</code> 是可选参数，指定分割的最大次数。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="python">sentence = &quot;Hello, how are you?&quot;
words = sentence.split()  # 默认以空格分割
print(words)  # 输出: [&#39;Hello,&#39;, &#39;how&#39;, &#39;are&#39;, &#39;you?&#39;]
</code></pre>
<p>也可以指定其他分隔符：</p>
<pre><code class="python">data = &quot;apple,orange,banana&quot;
fruits = data.split(&#39;,&#39;)
print(fruits)  # 输出: [&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;]
</code></pre>
</li>
<li><p><strong><code>strip()</code> 方法：</strong></p>
<ul>
<li><code>strip()</code> 方法用于去除字符串两端的空白字符（包括空格、制表符和换行符）。</li>
<li>语法：<code>str.strip([chars])</code><ul>
<li><code>chars</code> 是可选参数，指定要去除的字符，默认为去除空白字符。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="python">text = &quot;   This is a sentence.   &quot;
stripped_text = text.strip()
print(stripped_text)  # 输出: &#39;This is a sentence.&#39;
</code></pre>
<p>也可以指定要去除的特定字符：</p>
<pre><code class="python">text = &quot;!!!This is important!!!&quot;
stripped_text = text.strip(&#39;!&#39;)
print(stripped_text)  # 输出: &#39;This is important&#39;
</code></pre>
</li>
</ol>
<p>这两个方法在字符串处理中非常有用，<code>split()</code> 用于拆分字符串，而 <code>strip()</code> 用于去除字符串两端的空白字符或指定字符。</p>
<p>lower()  upper()方法</p>
<p>小写&#x2F;大写字母</p>
<h4><span id="in方法">in方法</span></h4><pre><code>var = &#39;hee&#39;
&#39;e&#39; in var
#返回true
</code></pre>
<h3><span id="4字典">4.字典</span></h3><p>是python中的唯一映射类型</p>
<p>在Python中，字典（Dictionary）是一种无序、可变的数据类型，用于存储键-值对。以下是字典的创建和访问字典中的值的方法：</p>
<ol>
<li><p><strong>字典的创建：</strong></p>
<ul>
<li><p>使用花括号 <code>&#123;&#125;</code> 创建字典，其中每个键值对用冒号 <code>:</code> 分隔，键和值之间用逗号 <code>,</code> 分隔。</p>
</li>
<li><p>例如：</p>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;
</code></pre>
</li>
<li><p>通过 <code>dict()</code> 构造函数也可以创建字典：</p>
<pre><code class="python">another_dict = dict(name=&quot;Alice&quot;, age=25, city=&quot;London&quot;)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>访问字典中的值：</strong></p>
<ul>
<li><p>使用键来访问字典中的值。通过指定键，可以获取相应的值。</p>
</li>
<li><p>例如：</p>
<pre><code class="python">print(my_dict[&quot;name&quot;])  # 输出: John
print(another_dict[&quot;age&quot;])  # 输出: 25
</code></pre>
</li>
<li><p>使用 <code>get()</code> 方法也可以访问值，如果键不存在，不会引发错误，而是返回一个默认值（默认为 <code>None</code>）：</p>
<pre><code class="python">print(my_dict.get(&quot;city&quot;))  # 输出: New York
print(my_dict.get(&quot;gender&quot;, &quot;Not specified&quot;))  # 输出: Not specified (因为 &quot;gender&quot; 不存在)
</code></pre>
</li>
<li><p>使用 <code>keys()</code> 方法可以获取所有的键，而 <code>values()</code> 方法可以获取所有的值：</p>
<pre><code class="python">keys = my_dict.keys()
values = my_dict.values()
print(keys)  # 输出: dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;city&#39;])
print(values)  # 输出: dict_values([&#39;John&#39;, 30, &#39;New York&#39;])
</code></pre>
</li>
</ul>
</li>
</ol>
<p>这些方法使得字典在存储和检索键值对时非常方便。字典中的键是唯一的，而值可以是任何数据类型。</p>
<p>在Python中，可以使用不同的方法来修改字典中的数据，包括添加新的键值对、更新现有的键值对以及删除键值对。</p>
<ol>
<li><p><strong>添加新的键值对：</strong></p>
<ul>
<li>可以通过指定新的键和相应的值，向字典中添加新的键值对。</li>
</ul>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;

# 添加新的键值对
my_dict[&quot;gender&quot;] = &quot;Male&quot;
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;, &#39;gender&#39;: &#39;Male&#39;&#125;
</code></pre>
</li>
<li><p><strong>更新现有的键值对：</strong></p>
<ul>
<li>可以通过指定已有的键来更新对应的值。</li>
</ul>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;

# 更新现有的键值对
my_dict[&quot;age&quot;] = 31
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 31, &#39;city&#39;: &#39;New York&#39;&#125;
</code></pre>
<ul>
<li>使用 <code>update()</code> 方法也可以一次性更新多个键值对。</li>
</ul>
<pre><code class="python">my_dict.update(&#123;&quot;age&quot;: 32, &quot;country&quot;: &quot;USA&quot;&#125;)
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 32, &#39;city&#39;: &#39;New York&#39;, &#39;country&#39;: &#39;USA&#39;&#125;
</code></pre>
</li>
<li><p><strong>删除键值对：</strong></p>
<ul>
<li>使用 <code>del</code> 关键字可以删除指定的键值对。</li>
</ul>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;

# 删除键值对
del my_dict[&quot;age&quot;]
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;, &#39;city&#39;: &#39;New York&#39;&#125;
</code></pre>
<ul>
<li>使用 <code>pop()</code> 方法也可以删除指定键的键值对，并返回被删除的值。</li>
</ul>
<pre><code class="python">removed_value = my_dict.pop(&quot;city&quot;)
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;&#125;
print(removed_value)
# 输出: New York
</code></pre>
</li>
</ol>
<p>这些操作使得字典成为一个灵活的数据结构，可以动态地修改和管理数据。</p>
<h4><span id="字典的操作方法">字典的操作方法</span></h4><p>字典是Python中的一种数据结构，它提供了许多有用的方法和操作，使得对键值对的管理更加方便。以下是一些常见的字典操作方法：</p>
<ol>
<li><p><strong>获取字典中的值：</strong></p>
<ul>
<li><p>使用键来获取字典中对应的值。</p>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;
print(my_dict[&quot;name&quot;])  # 输出: John
</code></pre>
</li>
<li><p>使用 <code>get()</code> 方法也可以获取值，并提供默认值以避免键不存在的错误。</p>
<pre><code class="python">print(my_dict.get(&quot;country&quot;, &quot;Not specified&quot;))  # 输出: Not specified
</code></pre>
</li>
</ul>
</li>
<li><p><strong>添加新的键值对：</strong></p>
<ul>
<li><p>使用赋值语句，通过指定新的键和相应的值，向字典中添加新的键值对。</p>
<pre><code class="python">my_dict[&quot;gender&quot;] = &quot;Male&quot;
</code></pre>
</li>
<li><p>使用 <code>update()</code> 方法一次性添加多个键值对。</p>
<pre><code class="python">my_dict.update(&#123;&quot;occupation&quot;: &quot;Engineer&quot;, &quot;salary&quot;: 50000&#125;)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>更新现有的键值对：</strong></p>
<ul>
<li><p>通过指定已有的键，更新对应的值。</p>
<pre><code class="python">my_dict[&quot;age&quot;] = 31
</code></pre>
</li>
<li><p>使用 <code>update()</code> 方法也可以一次性更新多个键值对。</p>
<pre><code class="python">my_dict.update(&#123;&quot;age&quot;: 32, &quot;country&quot;: &quot;USA&quot;&#125;)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>删除键值对：</strong></p>
<ul>
<li><p>使用 <code>del</code> 关键字删除指定的键值对。</p>
<pre><code class="python">del my_dict[&quot;age&quot;]
</code></pre>
</li>
<li><p>使用 <code>pop()</code> 方法删除指定键的键值对，并返回被删除的值。</p>
<pre><code class="python">removed_value = my_dict.pop(&quot;city&quot;)
</code></pre>
</li>
<li><p>使用 <code>popitem()</code> 方法删除并返回字典中的最后一个键值对。</p>
<pre><code class="python">last_item = my_dict.popitem()
</code></pre>
</li>
</ul>
</li>
<li><p><strong>获取所有键、所有值、所有键值对：</strong></p>
<ul>
<li><p>使用 <code>keys()</code> 方法获取所有的键。</p>
<pre><code class="python">keys = my_dict.keys()
</code></pre>
</li>
<li><p>使用 <code>values()</code> 方法获取所有的值。</p>
<pre><code class="python">values = my_dict.values()
</code></pre>
</li>
<li><p>使用 <code>items()</code> 方法获取所有的键值对。</p>
<pre><code class="python">items = my_dict.items()
</code></pre>
</li>
</ul>
<p>这些方法返回的结果是视图对象，可以将其转换为列表或其他数据类型以方便使用。</p>
</li>
<li><p><strong>清空字典：</strong></p>
<ul>
<li><p>使用 <code>clear()</code> 方法清空字典中所有的键值对。</p>
<pre><code class="python">my_dict.clear()
</code></pre>
</li>
</ul>
</li>
</ol>
<p>这些操作方法使得字典在实际应用中非常灵活，能够方便地进行添加、更新、删除和查询操作。</p>
<p>深复制（deep copy）和浅复制（shallow copy）是在Python中用于复制对象的两种不同方式。它们的主要区别在于复制的对象内部包含的子对象是否也被复制。</p>
<ol>
<li><p><strong>浅复制（Shallow Copy）：</strong></p>
<ul>
<li><p>浅复制创建一个新的对象，然后将原始对象中的元素（如列表、字典等）复制到新对象中。但是，对于原始对象中的子对象（如子列表、嵌套字典等），仅复制引用而不复制实际的子对象。</p>
</li>
<li><p>在Python中，可以使用 <code>copy()</code> 方法或 <code>copy</code> 模块中的 <code>copy()</code> 函数进行浅复制。</p>
<pre><code class="python">import copy

original_list = [1, [2, 3], 4]
shallow_copy_list = copy.copy(original_list)

print(original_list)         # 输出: [1, [2, 3], 4]
print(shallow_copy_list)     # 输出: [1, [2, 3], 4]

# 修改原始列表中的元素
original_list[1][0] = 99

print(original_list)         # 输出: [1, [99, 3], 4]
print(shallow_copy_list)     # 输出: [1, [99, 3], 4]（子列表被共享）
</code></pre>
</li>
<li><p>注意：浅复制只复制了对象本身以及对象中的元素，而没有递归地复制子对象。</p>
</li>
</ul>
</li>
<li><p><strong>深复制（Deep Copy）：</strong></p>
<ul>
<li><p>深复制创建一个新的对象，并递归地复制原始对象中的所有元素，包括子对象。</p>
</li>
<li><p>在Python中，可以使用 <code>copy</code> 模块中的 <code>deepcopy()</code> 函数进行深复制。</p>
<pre><code class="python">import copy

original_list = [1, [2, 3], 4]
deep_copy_list = copy.deepcopy(original_list)

print(original_list)         # 输出: [1, [2, 3], 4]
print(deep_copy_list)        # 输出: [1, [2, 3], 4]

# 修改原始列表中的元素
original_list[1][0] = 99

print(original_list)         # 输出: [1, [99, 3], 4]
print(deep_copy_list)        # 输出: [1, [2, 3], 4]（子列表不被共享）
</code></pre>
</li>
<li><p>深复制会递归地复制整个对象结构，包括对象中的所有子对象，因此即使修改了原始对象的子对象，深复制的对象也不受影响。</p>
</li>
</ul>
</li>
</ol>
<p>选择使用浅复制还是深复制取决于应用的需求。如果对象中没有嵌套的可变对象或者不需要对嵌套的可变对象进行独立修改，那么浅复制可能足够。如果对象包含嵌套的可变对象，而且需要独立修改它们，那么深复制更合适。</p>
<h3><span id="5集合">5.集合</span></h3><p>用set()函数来创建集合</p>
<p>删除：remove（）</p>
<p>添加：add（）</p>
<p>拆分传入：update（）</p>
<pre><code class="python">a = set(&#39;i love&#39;)
a.update(&#39;python&#39;)
#&#123;&#39;i&#39;, &#39; &#39;, &#39;l&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;n&#39;&#125;
</code></pre>
<p>集合可以做数学操作</p>
<h2><span id="七异常的处理和文件操作">七，异常的处理和文件操作</span></h2><h3><span id="1异常处理">1.异常处理</span></h3><p>在Python中，异常处理是一种机制，用于捕获和处理程序执行中可能发生的异常或错误。Python提供了<code>try</code>和<code>except</code>块来实现异常处理。以下是基本的异常处理结构：</p>
<pre><code class="python">try:
    # 代码块，可能会引发异常的部分
    # ...
except ExceptionType as e:
    # 异常处理块，处理发生的特定类型的异常
    # ...
else:
    # 可选的 else 块，在没有异常发生时执行
    # ...
finally:
    # 可选的 finally 块，无论是否发生异常都会执行
    # ...
</code></pre>
<ul>
<li><code>try</code> 块包含可能引发异常的代码。</li>
<li><code>except</code> 块用于捕获并处理指定类型的异常。可以捕获多个异常类型，也可以省略异常类型捕获所有异常。</li>
<li><code>else</code> 块（可选）在没有异常发生时执行。</li>
<li><code>finally</code> 块（可选）无论是否发生异常都会执行，通常用于进行清理操作。</li>
</ul>
<p>示例：</p>
<pre><code class="python">try:
    x = 10 / 0  # 除零错误
except ZeroDivisionError as e:
    print(f&quot;Error: &#123;e&#125;&quot;)
else:
    print(&quot;No error occurred.&quot;)
finally:
    print(&quot;This will always execute.&quot;)
</code></pre>
<p>在上面的例子中，由于除零错误，控制流将跳转到<code>except</code>块，并输出错误信息。然后，<code>finally</code>块中的语句总是执行。</p>
<p>除了基本的<code>try</code>和<code>except</code>，还有其他一些关键字和语句，例如<code>raise</code>（用于手动引发异常）和<code>assert</code>（用于断言条件是否为真）。异常处理是编写健壮和容错代码的重要部分。</p>
<h3><span id="2文件操作">2.文件操作</span></h3><p>在Python中，文件操作是常见的任务之一，用于读取和写入文件。以下是一些常用的文件操作方法：</p>
<ol>
<li><p><strong>打开文件：</strong><br>使用 <code>open()</code> 函数来打开文件。该函数返回一个文件对象，可以用于读取或写入文件。</p>
<pre><code class="python"># 打开文件以供读取
file = open(&quot;example.txt&quot;, &quot;r&quot;)

# 打开文件以供写入（若文件不存在则创建）
file = open(&quot;example.txt&quot;, &quot;w&quot;)
</code></pre>
<p>参数：</p>
<ul>
<li>第一个参数是文件路径。</li>
<li>第二个参数是打开文件的模式：<ul>
<li><code>&quot;r&quot;</code>: 只读模式</li>
<li><code>&quot;w&quot;</code>: 写入模式（若文件存在则清空内容，若文件不存在则创建）</li>
<li><code>&quot;a&quot;</code>: 追加模式（在文件末尾追加内容，若文件不存在则创建）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>读取文件内容：</strong><br>使用文件对象的 <code>read()</code> 方法来读取文件内容。</p>
<pre><code class="python">content = file.read()
print(content)
</code></pre>
</li>
<li><p><strong>写入文件内容：</strong><br>使用文件对象的 <code>write()</code> 方法来写入内容到文件。</p>
<pre><code class="python">file.write(&quot;Hello, this is a sample text.&quot;)
</code></pre>
<p>要确保写入后使用 <code>close()</code> 方法关闭文件，或者使用 <code>with</code> 语句来自动关闭文件。</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;w&quot;) as file:
    file.write(&quot;Hello, this is a sample text.&quot;)
</code></pre>
</li>
<li><p><strong>逐行读取文件：</strong><br>使用文件对象的 <code>readline()</code> 方法来逐行读取文件内容。</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    line = file.readline()
    while line:
        print(line)
        line = file.readline()
</code></pre>
</li>
<li><p><strong>迭代文件对象：</strong><br>文件对象本身就是可迭代的，可以直接在 <code>for</code> 循环中使用。</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    for line in file:
        print(line)
</code></pre>
</li>
<li><p><strong>关闭文件：</strong><br>使用文件对象的 <code>close()</code> 方法来关闭文件。</p>
<pre><code class="python">file.close()
</code></pre>
<p>或者使用 <code>with</code> 语句，它会在代码块执行完毕后自动关闭文件。</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    content = file.read()
    # 文件在这里自动关闭
</code></pre>
</li>
</ol>
<p>以上是文件的基本读取和写入操作。在实际应用中，还可以使用异常处理来处理文件操作可能引发的异常，例如文件不存在、权限错误等。</p>
<p>replace函数：</p>
<p>在Python中，<code>replace()</code> 是字符串对象的方法之一，用于替换字符串中的指定子串。这个方法的基本语法如下：</p>
<pre><code class="python">str.replace(old, new[, count])
</code></pre>
<ul>
<li><code>old</code>: 要被替换的子串。</li>
<li><code>new</code>: 替换后的新子串。</li>
<li><code>count</code> (可选): 指定替换的次数。如果提供了 <code>count</code> 参数，则只替换前 <code>count</code> 次出现的子串。</li>
</ul>
<p>下面是一个简单的例子：</p>
<pre><code class="python">sentence = &quot;I love programming. Programming is fun.&quot;

# 将 &quot;Programming&quot; 替换为 &quot;Coding&quot;
new_sentence = sentence.replace(&quot;Programming&quot;, &quot;Coding&quot;)

print(new_sentence)
# 输出: &quot;I love coding. Coding is fun.&quot;
</code></pre>
<p>在上面的例子中，<code>replace()</code> 方法将字符串中所有的 “Programming” 替换为 “Coding”。</p>
<p>需要注意的是，<code>replace()</code> 方法返回一个新的字符串，原始字符串并没有被修改。如果需要修改原始字符串，可以将结果赋值给原始字符串变量。</p>
<pre><code class="python">sentence = &quot;I love programming. Programming is fun.&quot;

# 修改原始字符串
sentence = sentence.replace(&quot;Programming&quot;, &quot;Coding&quot;)

print(sentence)
# 输出: &quot;I love coding. Coding is fun.&quot;
</code></pre>
<p>这个方法在文本处理、字符串清理等场景中很常见。</p>
<h3><span id="3with语句">3.with语句</span></h3><p><code>with</code> 语句是 Python 中用于简化资源管理的一种语法结构。它通常用于对文件、网络连接、数据库连接等需要手动管理的资源进行操作，以确保在离开代码块时资源被正确释放。<code>with</code> 语句的一般形式如下：</p>
<pre><code class="python">with expression as variable:
    # 代码块，对资源进行操作
    # 在退出代码块时，确保资源被正确释放
</code></pre>
<p><code>expression</code> 是一个返回上下文管理器对象的表达式，它定义了资源的进入和退出时的操作。<code>variable</code> 是一个变量名，用于引用上下文管理器对象。</p>
<p>最常见的用法是在文件操作中，例如打开文件：</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    content = file.read()
    # 在这里文件已经被打开
    # 在离开这个代码块时，文件会被自动关闭，不需要显式调用 file.close()
</code></pre>
<p>在上述例子中，<code>open(&quot;example.txt&quot;, &quot;r&quot;)</code> 返回一个文件对象，这个文件对象是一个上下文管理器，负责在进入和退出代码块时执行相应的操作。在 <code>with</code> 语句的代码块中，可以使用文件对象进行读取或写入操作，而在退出代码块时，文件会被自动关闭，无论代码块中是否发生异常。</p>
<p>用as关键字来取代原来的赋值语句</p>
<p><code>with</code> 语句的好处包括：</p>
<ol>
<li><p><strong>资源自动管理：</strong> 确保在代码块执行完毕后，资源会被正确释放，不需要手动调用释放资源的方法。</p>
</li>
<li><p><strong>异常处理：</strong> 在代码块中发生异常时，<code>with</code> 语句会确保退出时正确处理异常，避免资源泄漏。</p>
</li>
<li><p><strong>代码简洁：</strong> 避免了繁琐的 try-except-finally 结构，使代码更加简洁易读。</p>
</li>
</ol>
<p><code>with</code> 语句在处理一些需要管理上下文的场景中非常有用，例如文件操作、数据库连接等。</p>
<h2><span id="八面向对象编程">八，面向对象编程</span></h2><h3><span id="1类的定义与实例化">1.类的定义与实例化</span></h3><p>在Python中，构造方法是类的特殊方法，用于初始化对象的属性。构造方法的名称是固定的，它应该被命名为 <code>__init__</code>。构造方法的格式和要求如下：</p>
<pre><code class="python">class ClassName:
    def __init__(self, parameter1, parameter2, ...):
        # 构造方法的实现
        self.attribute1 = parameter1
        self.attribute2 = parameter2
        # ...
</code></pre>
<p>要点说明：</p>
<ol>
<li><p><strong>方法名称：</strong> 构造方法的名称必须是 <code>__init__</code>。</p>
</li>
<li><p><strong>参数 <code>self</code>：</strong> 构造方法的第一个参数必须是 <code>self</code>，它代表创建的对象实例。在方法内部，通过 <code>self</code> 可以访问该对象的属性和其他方法。</p>
</li>
<li><p><strong>其他参数：</strong> 构造方法可以包含除 <code>self</code> 之外的其他参数，用来接收创建对象时传递的初始值。这些参数通常用于初始化对象的属性。</p>
</li>
<li><p><strong>属性初始化：</strong> 在构造方法中，可以通过 <code>self</code> 来初始化对象的属性。例如，<code>self.attribute1 = parameter1</code> 将构造方法中传入的 <code>parameter1</code> 赋值给对象的属性 <code>attribute1</code>。</p>
</li>
</ol>
<p>示例：</p>
<pre><code class="python">class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
person1 = Person(&quot;Alice&quot;, 25)

# 访问对象的属性
print(person1.name)  # 输出: Alice
print(person1.age)   # 输出: 25
</code></pre>
<p>这是一个简单的构造方法的例子，演示了如何通过构造方法初始化对象的属性。构造方法在创建对象时自动调用，用于确保对象在被使用之前被正确初始化。</p>
<h3><span id="2类的完整定义">2.类的完整定义</span></h3><p>在Python中，一个类的完整定义包括类的名称、类的属性（成员变量）、类的方法（成员方法）以及可能的构造方法。下面是一个简单的类的完整定义示例：</p>
<pre><code class="python">class MyClass:
    # 类的属性
    class_variable = &quot;I am a class variable&quot;

    # 构造方法
    def __init__(self, param1, param2):
        self.instance_variable1 = param1
        self.instance_variable2 = param2

    # 类的方法
    def instance_method(self):
        print(&quot;I am an instance method.&quot;)

    @classmethod
    def class_method(cls):
        print(&quot;I am a class method. Class variable:&quot;, cls.class_variable)

    @staticmethod
    def static_method():
        print(&quot;I am a static method.&quot;)

# 创建一个对象实例
obj = MyClass(&quot;value1&quot;, &quot;value2&quot;)

# 访问对象的属性和调用方法
print(obj.instance_variable1)   # 输出: value1
obj.instance_method()            # 输出: I am an instance method.

# 访问类的属性和调用类方法
print(MyClass.class_variable)    # 输出: I am a class variable
MyClass.class_method()           # 输出: I am a class method. Class variable: I am a class variable

# 调用静态方法
MyClass.static_method()          # 输出: I am a static method.
</code></pre>
<p>上述代码中，<code>MyClass</code> 是一个简单的类，它包含了类的属性 <code>class_variable</code>、构造方法 <code>__init__</code>、实例方法 <code>instance_method</code>、类方法 <code>class_method</code> 和静态方法 <code>static_method</code>。在创建类的对象实例后，可以通过对象实例访问属性和调用方法，也可以通过类名访问类的属性和调用类方法。</p>
<h3><span id="3对象属性的默认值设置">3.对象属性的默认值设置</span></h3><p>在Python中，可以在类的构造方法中为对象属性设置默认值。这可以通过在构造方法中为参数提供默认值来实现。如果创建对象时没有提供特定属性的值，则使用默认值。</p>
<p>以下是一个示例，演示如何在构造方法中设置对象属性的默认值：</p>
<pre><code class="python">class Person:
    def __init__(self, name=&quot;Unknown&quot;, age=0):
        # 设置对象属性的默认值
        self.name = name
        self.age = age

# 创建对象实例，不提供任何参数，使用默认值
person1 = Person()

# 创建对象实例，提供部分参数，使用默认值
person2 = Person(name=&quot;Alice&quot;)

# 创建对象实例，提供所有参数，不使用默认值
person3 = Person(name=&quot;Bob&quot;, age=30)

# 打印对象属性
print(person1.name, person1.age)  # 输出: Unknown 0
print(person2.name, person2.age)  # 输出: Alice 0
print(person3.name, person3.age)  # 输出: Bob 30
</code></pre>
<p>在上述示例中，<code>Person</code> 类的构造方法中有两个参数 <code>name</code> 和 <code>age</code>，并为它们设置了默认值。当创建对象实例时，如果没有提供这两个参数，则会使用默认值。如果提供了参数，则使用提供的值。</p>
<p>这种方式使得对象的创建更加灵活，可以根据需要提供或者不提供特定属性的值。</p>
<h3><span id="4私有属性">4.私有属性</span></h3><p>在Python中，可以使用双下划线 (<code>__</code>) 或者单下划线（’_’）前缀来定义私有属性和私有方法。私有属性和私有方法只能在类的内部访问，外部无法直接访问它们。这有助于封装类的内部实现细节，防止外部直接修改或调用。</p>
<p>私有属性：</p>
<p>在类中定义私有属性的格式是在<strong>属性名称前</strong>加上双下划线 (<code>__</code>)。例如：</p>
<pre><code class="python">class MyClass:
    def __init__(self):
        # 定义私有属性
        self.__private_attribute = 42

    def get_private_attribute(self):
        # 在类的方法中访问私有属性
        return self.__private_attribute

# 创建对象实例
obj = MyClass()

# 无法直接访问私有属性，会引发 AttributeError
# print(obj.__private_attribute)

# 通过类的方法访问私有属性
print(obj.get_private_attribute())  # 输出: 42
</code></pre>
<p>私有方法：</p>
<p>在类中定义私有方法的格式也是在方法名称前加上双下划线 (<code>__</code>)。例如：</p>
<pre><code class="python">class MyClass:
    def __init__(self):
        pass

    # 定义私有方法
    def __private_method(self):
        return &quot;This is a private method.&quot;

    def public_method(self):
        # 在类的方法中调用私有方法
        result = self.__private_method()
        return result

# 创建对象实例
obj = MyClass()

# 无法直接调用私有方法，会引发 AttributeError
# obj.__private_method()

# 通过类的公有方法调用私有方法
print(obj.public_method())  # 输出: This is a private method.
</code></pre>
<p>在上述例子中，私有属性和私有方法只能通过类的内部方法进行访问或调用。外部无法直接访问私有属性或调用私有方法。这有助于保护类的内部实现，并提高代码的封装性。</p>
<h3><span id="5类属性">5.类属性</span></h3><p>类属性就是定义在类中的一个属性，是必须通过<strong>类名</strong>访问的属性，类的所有实例共享类属性</p>
<h3><span id="6类的继承">6.类的继承</span></h3><h4><span id="1-类的继承">（1）. 类的继承：</span></h4><p>在Python中，可以通过继承来创建一个新的类，新类称为子类，继承的类称为父类。子类可以继承父类的属性和方法，也可以添加自己的属性和方法。继承的基本语法如下：</p>
<pre><code class="python">class ParentClass:
    # 父类的属性和方法

class ChildClass(ParentClass):
    # 子类的属性和方法
</code></pre>
<h4><span id="2-子类方法对父类方法的覆盖">（2）. 子类方法对父类方法的覆盖：</span></h4><p>子类可以对父类的方法进行覆盖（重写），即在子类中定义与父类同名的方法。这样，当对象是子类的实例时，调用同名方法时将使用子类的方法而不是父类的方法。示例：</p>
<pre><code class="python">class ParentClass:
    def show_message(self):
        print(&quot;This is the parent class.&quot;)

class ChildClass(ParentClass):
    def show_message(self):
        print(&quot;This is the child class.&quot;)

# 创建子类对象
child_obj = ChildClass()

# 调用覆盖的方法
child_obj.show_message()  # 输出: This is the child class.
</code></pre>
<h4><span id="3-在子类方法中调用父类的同名方法">（3）. 在子类方法中调用父类的同名方法：</span></h4><p>如果在子类的方法中要调用父类的同名方法，可以使用 <code>super()</code> 函数。<code>super()</code> 返回父类的临时对象，可以调用父类的方法。示例：</p>
<pre><code class="python">class ParentClass:
    def show_message(self):
        print(&quot;This is the parent class.&quot;)

class ChildClass(ParentClass):
    def show_message(self):
        # 调用父类的同名方法
        super().show_message()
        print(&quot;This is the child class.&quot;)

# 创建子类对象
child_obj = ChildClass()

# 调用子类的方法
child_obj.show_message()
</code></pre>
<p>在上述例子中，<code>super().show_message()</code> 调用了父类的 <code>show_message</code> 方法，然后在子类的方法中添加了额外的输出。这样可以保留父类方法的功能，并在子类方法中进行扩展。</p>
<h2><span id="九图形的用户界面">九，图形的用户界面</span></h2><p>Tkinter是python的默认GUI库</p>
<h3><span id="1创建">1.创建</span></h3><p>在Python中，可以使用<code>tkinter</code>库创建GUI（图形用户界面）应用程序。下面是一个简单的例子，演示如何创建并运行一个基本的Tkinter GUI窗口：</p>
<p><strong>TK（）是tkinter库中的构造方法</strong></p>
<pre><code class="python">import tkinter as tk

class SimpleGUI:
    def __init__(self, master):
        self.master = master
        master.title(&quot;Simple GUI&quot;)

        self.label = tk.Label(master, text=&quot;Hello, Tkinter!&quot;)
        self.label.pack()

        self.button = tk.Button(master, text=&quot;Click Me&quot;, command=self.on_button_click)
        self.button.pack()

    def on_button_click(self):
        self.label.config(text=&quot;Button Clicked!&quot;)

# 创建主窗口
root = tk.Tk()

# 创建并运行GUI
app = SimpleGUI(root)

# 运行主循环
root.mainloop()
</code></pre>
<p>[^关于创建两次对象]: 在这两句代码中，<code>root = tk.Tk()</code> 创建了一个 Tkinter 主窗口对象，而 <code>app = SimpleGUI(root)</code> 创建了一个 <code>SimpleGUI</code> 类的对象，并将刚刚创建的 Tkinter 主窗口对象传递给它作为参数。执行的顺序通常是按照代码的顺序进行的，因此在这里，确实是先创建了 Tkinter 主窗口对象，然后创建了 <code>SimpleGUI</code> 类的对象。这种顺序通常是符合逻辑的，因为在创建 <code>SimpleGUI</code> 对象时，你可能需要传递主窗口对象，并在构造方法中进行一些初始化工作。如果反过来，先创建 <code>SimpleGUI</code> 对象，而构造方法又需要主窗口对象作为参数，那么你就需要确保在创建 <code>SimpleGUI</code> 对象之前已经有了主窗口对象。所以，这两句代码的顺序通常是按照先创建主窗口，然后再创建 GUI 对象的方式进行的。</p>
<p>这个例子创建了一个简单的Tkinter GUI窗口，包含一个标签和一个按钮。当按钮被点击时，标签的文本将被更新。以下是代码的解释：</p>
<ul>
<li><code>tk.Tk()</code> 创建了一个主窗口对象。</li>
<li><code>SimpleGUI</code> 类是我们创建的GUI应用程序的主要类。在构造方法 <code>__init__</code> 中，我们定义了窗口的标题、标签和按钮，并将它们打包（pack）到窗口中。</li>
<li><code>on_button_click</code> 方法是按钮点击事件的处理函数，它会更新标签的文本。</li>
<li><code>root.mainloop()</code> 启动了Tkinter的主循环，使窗口保持打开状态并等待用户交互。</li>
</ul>
<p>要运行这个代码，确保你的Python环境中安装了<code>tkinter</code>库，然后将代码保存为<code>.py</code>文件，运行即可看到GUI窗口。</p>
<p><strong>关于为什么要起别名：</strong></p>
<p><strong>以及是用库名来调用库中的方法</strong></p>
<p>这句代码 <code>import tkinter as tk</code> 表示导入 <code>tkinter</code> 模块，并为它起了一个别名 <code>tk</code>。这样，你可以使用 <code>tk</code> 这个别名来调用 <code>tkinter</code> 模块中的方法和类，使代码更简洁。</p>
<p>例如，原本你可能会这样写：</p>
<pre><code class="python">import tkinter

root = tkinter.Tk()
label = tkinter.Label(root, text=&quot;Hello, Tkinter!&quot;)
root.mainloop()
</code></pre>
<p>使用别名后，你可以写成：</p>
<pre><code class="python">import tkinter as tk

root = tk.Tk()
label = tk.Label(root, text=&quot;Hello, Tkinter!&quot;)
root.mainloop()
</code></pre>
<p>这样做的好处是减少代码中的重复，使代码更简洁易读。别名的选择通常是根据个人或团队的习惯，只要不与其他已有的名称冲突即可。</p>
<h3><span id="2在窗口中加入组件">2.在窗口中加入组件</span></h3><h4><span id="按钮的创建">按钮的创建</span></h4><p><strong>tk.Button</strong></p>
<p>在 Tkinter 中，可以使用 <code>Button</code> 类来创建按钮。以下是一个简单的例子，演示如何创建一个按钮：</p>
<pre><code class="python">import tkinter as tk

class SimpleGUI:
    def __init__(self, master):
        self.master = master
        master.title(&quot;Simple GUI&quot;)

        self.label = tk.Label(master, text=&quot;Hello, Tkinter!&quot;)
        self.label.pack()

        # 创建按钮
        self.button = tk.Button(master, text=&quot;Click Me&quot;, command=self.on_button_click)
        self.button.pack()

    def on_button_click(self):
        self.label.config(text=&quot;Button Clicked!&quot;)

# 创建主窗口
root = tk.Tk()

# 创建并运行 GUI
app = SimpleGUI(root)

# 运行主循环
root.mainloop()
</code></pre>
<p>在上面的例子中，通过 <code>tk.Button</code> 创建了一个按钮对象，并通过 <code>text</code> 参数设置按钮上的文本。<code>command</code> 参数指定了按钮点击时要调用的函数，这里是 <code>on_button_click</code> 方法。按钮创建后，使用 <code>pack()</code> 方法将按钮添加到主窗口中。</p>
<p>当按钮被点击时，<code>on_button_click</code> 方法会被调用，其中我们通过 <code>self.label.config()</code> 更新了标签的文本。</p>
<p>你可以根据需要自定义按钮的外观、行为以及与按钮相关联的事件处理函数。</p>
<h4><span id="按钮的动作">按钮的动作</span></h4><p><strong>command</strong></p>
<p>在Tkinter中，可以使用<code>command</code>参数为按钮设置动作事件。动作事件是指当按钮被点击时执行的操作。你可以将一个函数或方法绑定到按钮，使其在按钮被点击时调用。</p>
<p>下面是一个例子，演示如何为按钮设置动作事件：</p>
<pre><code class="python">import tkinter as tk

class SimpleGUI:
    def __init__(self, master):
        self.master = master
        master.title(&quot;Simple GUI&quot;)

        self.label = tk.Label(master, text=&quot;Hello, Tkinter!&quot;)
        self.label.pack()

        # 创建按钮并设置动作事件
        self.button = tk.Button(master, text=&quot;Click Me&quot;, command=self.on_button_click)
        self.button.pack()

    def on_button_click(self):
        self.label.config(text=&quot;Button Clicked!&quot;)
        # 在按钮点击时执行的其他操作

# 创建主窗口
root = tk.Tk()

# 创建并运行 GUI
app = SimpleGUI(root)

# 运行主循环
root.mainloop()
</code></pre>
<p>在上述例子中，<code>command=self.on_button_click</code> 将按钮的动作事件与 <code>on_button_click</code> 方法关联起来。当按钮被点击时，<code>on_button_click</code> 方法会被调用，其中我们更新了标签的文本，并可以在该方法中执行其他需要在按钮点击时进行的操作。</p>
<p>你可以根据需要定义其他的动作事件处理方法，然后将它们与按钮关联，以实现特定的功能。</p>
<h4><span id="按钮的坐标管理">按钮的坐标管理</span></h4><p>在Tkinter中，按钮的坐标管理通常通过不同的几何管理器（geometry manager）来完成。Tkinter支持三种主要的几何管理器：<code>pack</code>、<code>grid</code>和<code>place</code>。这些几何管理器允许你在窗口中放置按钮并管理它们的位置。</p>
<p>以下是每个几何管理器的简要说明：</p>
<ol>
<li><p><strong><code>pack</code> 几何管理器：</strong> <code>pack</code> 将组件放置在其父容器的边缘上，可以指定组件的位置，但默认是垂直排列。示例：</p>
<pre><code class="python">self.button.pack(side=&quot;left&quot;, padx=10, pady=10)
</code></pre>
</li>
<li><p><strong><code>grid</code> 几何管理器：</strong> <code>grid</code> 将组件放置在一个表格中，可以指定组件的行和列。示例：</p>
<pre><code class="python">self.button.grid(row=0, column=0, padx=10, pady=10)
</code></pre>
</li>
<li><p><strong><code>place</code> 几何管理器：</strong> <code>place</code> 允许你以绝对坐标放置组件，相对于其父容器的左上角。示例：</p>
<pre><code class="python">self.button.place(x=50, y=50)
</code></pre>
</li>
</ol>
<p>以下是一个完整的示例，演示如何使用<code>pack</code>、<code>grid</code>和<code>place</code>来管理按钮的坐标：</p>
<pre><code class="python">import tkinter as tk

class GeometryManagerExample:
    def __init__(self, master):
        self.master = master
        master.title(&quot;Geometry Manager Example&quot;)

        # 创建按钮并使用 pack 几何管理器
        button_pack = tk.Button(master, text=&quot;Pack&quot;)
        button_pack.pack(side=&quot;left&quot;, padx=10, pady=10)

        # 创建按钮并使用 grid 几何管理器
        button_grid = tk.Button(master, text=&quot;Grid&quot;)
        button_grid.grid(row=0, column=1, padx=10, pady=10)

        # 创建按钮并使用 place 几何管理器
        button_place = tk.Button(master, text=&quot;Place&quot;)
        button_place.place(x=100, y=50)

# 创建主窗口
root = tk.Tk()

# 创建并运行 GUI
app = GeometryManagerExample(root)

# 运行主循环
root.mainloop()
</code></pre>
<p>在这个例子中，三个按钮分别使用了<code>pack</code>、<code>grid</code>和<code>place</code>几何管理器，你可以根据需要选择适合你布局的管理器。</p>
<h3><span id="3tkinter组件及其属性">3.Tkinter组件及其属性</span></h3><h4><span id="label组件和entry组件">label组件和entry组件</span></h4><p>在Python中，<code>tkinter</code> 模块是一个常用的图形用户界面（GUI）工具包，它包含了创建窗口和各种界面元素的类和方法。<code>Label</code> 组件和 <code>Entry</code> 组件是两个常用的界面元素，用于显示文本和接收用户输入。</p>
<ol>
<li><p><strong>Label（标签）组件:</strong><br><code>Label</code> 组件用于在窗口中显示静态文本或图像。以下是一个简单的示例，演示如何创建一个标签组件：</p>
<pre><code class="python">import tkinter as tk

root = tk.Tk()
label = tk.Label(root, text=&quot;这是一个标签&quot;)
label.pack()

root.mainloop()
</code></pre>
<p>在这个例子中，创建了一个 <code>Tk</code> 窗口，并在窗口中放置了一个标签，标签上显示着文本 “这是一个标签”。</p>
</li>
<li><p><strong>Entry（输入框）组件:</strong><br><code>Entry</code> 组件用于允许用户输入文本。以下是一个简单的示例，演示如何创建一个输入框组件：</p>
<pre><code class="python">import tkinter as tk

def on_button_click():
    entered_text = entry.get()
    print(&quot;输入的文本是:&quot;, entered_text)

root = tk.Tk()

entry = tk.Entry(root)
entry.pack()

button = tk.Button(root, text=&quot;获取文本&quot;, command=on_button_click)
button.pack()

root.mainloop()
</code></pre>
<p>在这个例子中，创建了一个输入框和一个按钮。当用户输入文本并点击按钮时，程序将获取输入框中的文本并打印出来。</p>
</li>
</ol>
<p>以上代码只是简单的演示，你可以根据需要进行更复杂的界面设计和交互。希望这能帮助你开始使用 <code>Label</code> 和 <code>Entry</code> 组件。</p>
<h4><span id="listbox组件">listbox组件</span></h4><p><code>tkinter</code> 中的 <code>Listbox</code> 组件用于在窗口中显示一个列表，并允许用户选择其中的项。以下是一个简单的示例，演示如何创建和使用 <code>Listbox</code> 组件：</p>
<pre><code class="python">import tkinter as tk

def on_select(event):
    selected_item = listbox.get(listbox.curselection())
    print(&quot;选择的项是:&quot;, selected_item)

root = tk.Tk()

# 创建 Listbox 组件
listbox = tk.Listbox(root, selectmode=tk.SINGLE)
listbox.pack()

# 向 Listbox 中添加项
for item in [&quot;项1&quot;, &quot;项2&quot;, &quot;项3&quot;, &quot;项4&quot;]:
    listbox.insert(tk.END, item)

# 绑定选择事件
listbox.bind(&#39;&lt;&lt;ListboxSelect&gt;&gt;&#39;, on_select)

root.mainloop()
</code></pre>
<p>在这个例子中，创建了一个 <code>Tk</code> 窗口和一个 <code>Listbox</code> 组件。通过使用 <code>insert</code> 方法，将一些项添加到列表框中。然后，使用 <code>bind</code> 方法绑定了选择事件，当用户选择列表框中的项时，触发 <code>on_select</code> 函数。</p>
<p><code>on_select</code> 函数获取用户选择的项，并打印出来。请注意，<code>selectmode</code> 参数指定了选择模式，<code>tk.SINGLE</code> 表示只能选择一个项。</p>
<p>你可以根据需要更改选择模式，也可以使用 <code>listbox.curselection()</code> 获取当前选择的索引。这只是一个简单的示例，你可以根据实际需求进行更复杂的列表框设计。</p>
<h4><span id="canvas组件">canvas组件</span></h4><p><code>tkinter</code> 中的 <code>Canvas</code> 组件用于创建绘图区域，允许你在窗口中绘制图形、文本和其他元素。以下是一个简单的示例，演示如何创建和使用 <code>Canvas</code> 组件：</p>
<pre><code class="python">import tkinter as tk

def draw_circle():
    canvas.create_oval(50, 50, 150, 150, fill=&quot;blue&quot;)

def draw_rectangle():
    canvas.create_rectangle(200, 50, 300, 150, fill=&quot;red&quot;)

root = tk.Tk()

# 创建 Canvas 组件
canvas = tk.Canvas(root, width=400, height=200)
canvas.pack()

# 创建按钮并绑定绘制函数
circle_button = tk.Button(root, text=&quot;绘制圆形&quot;, command=draw_circle)
circle_button.pack(side=tk.LEFT)

rectangle_button = tk.Button(root, text=&quot;绘制矩形&quot;, command=draw_rectangle)
rectangle_button.pack(side=tk.LEFT)

root.mainloop()
</code></pre>
<p>在这个例子中，创建了一个 <code>Tk</code> 窗口和一个 <code>Canvas</code> 组件。通过 <code>create_oval</code> 方法和 <code>create_rectangle</code> 方法，可以在画布上绘制圆形和矩形。两个按钮分别触发 <code>draw_circle</code> 和 <code>draw_rectangle</code> 函数，绘制对应的图形。</p>
<p>可以根据需要在画布上绘制各种形状、线条、文本等。<code>Canvas</code> 组件提供了多个方法来进行绘图，可以满足各种绘图需求。</p>
<h2><span id="十数据分析与可视化">十，数据分析与可视化</span></h2><h3><span id="1数值计算库numpy">1.数值计算库numpy</span></h3><p><code>NumPy</code> 是一个用于数值计算的强大的 Python 库。它提供了一个多维数组对象（<code>numpy.ndarray</code>）和一组用于处理这些数组的函数。以下是一些 <code>NumPy</code> 的基本用法和功能：</p>
<ol>
<li><p><strong>导入 NumPy：</strong><br>在使用 NumPy 之前，需要导入它：</p>
<pre><code class="python">import numpy as np
</code></pre>
<p>通常使用 <code>np</code> 作为别名，以方便在代码中引用 NumPy。</p>
</li>
<li><p><strong>创建数组：</strong><br>使用 <code>numpy.array</code> 函数可以创建 NumPy 数组：</p>
<pre><code class="python">arr = np.array([1, 2, 3, 4, 5])
</code></pre>
<p>这样就创建了一个包含 <code>[1, 2, 3, 4, 5]</code> 的一维数组。</p>
</li>
<li><p><strong>基本操作：</strong><br>NumPy 数组支持基本的数学运算，例如加法、减法、乘法和除法：</p>
<pre><code class="python">a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

result = a + b
</code></pre>
<p><code>result</code> 将包含 <code>[5, 7, 9]</code>。</p>
</li>
<li><p><strong>多维数组：</strong><br>NumPy 支持多维数组，可以创建二维、三维等数组：</p>
<pre><code class="python">matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
</code></pre>
<p>这是一个3x3的二维数组。</p>
</li>
<li><p><strong>数组索引和切片：</strong><br>NumPy 数组可以通过索引和切片进行访问和操作：</p>
<pre><code class="python">a = np.array([1, 2, 3, 4, 5])
print(a[2])  # 输出: 3
</code></pre>
<p>或者：</p>
<pre><code class="python">matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(matrix[1, 2])  # 输出: 6
</code></pre>
</li>
<li><p><strong>数学函数：</strong><br>NumPy 提供了许多数学函数，如 <code>np.sin</code>、<code>np.cos</code>、<code>np.exp</code> 等，可以在数组上进行元素级别的操作。</p>
<pre><code class="python">angles = np.array([0, np.pi/2, np.pi])
sin_values = np.sin(angles)
</code></pre>
<p><code>sin_values</code> 将包含 <code>[0, 1, 0]</code>。</p>
</li>
</ol>
<p>这只是 NumPy 的一小部分功能，它还包括线性代数、统计、随机数生成等功能。</p>
<h3><span id="2科学计算扩展库scipy">2.科学计算扩展库scipy</span></h3><p><code>SciPy</code> 是建立在 <code>NumPy</code> 基础上的科学计算扩展库，它提供了许多用于解决科学和工程问题的高级功能。<code>SciPy</code> 包含了许多子模块，每个子模块都专注于解决特定类型的问题。以下是一些 <code>SciPy</code> 子模块和其功能的简要介绍：</p>
<ol>
<li><p><strong>插值（Interpolation）：</strong><br><code>scipy.interpolate</code> 模块提供了插值函数，用于在给定数据点之间进行插值。</p>
</li>
<li><p><strong>优化（Optimization）：</strong><br><code>scipy.optimize</code> 模块包含了各种最优化算法，用于寻找函数的最小值或最大值。</p>
</li>
<li><p><strong>线性代数（Linear Algebra）：</strong><br><code>scipy.linalg</code> 模块扩展了 <code>NumPy</code> 的线性代数功能，提供了更多的线性代数操作。</p>
</li>
<li><p><strong>信号处理（Signal Processing）：</strong><br><code>scipy.signal</code> 模块包含了许多信号处理工具，如滤波、频谱分析等。</p>
</li>
<li><p><strong>统计（Statistics）：</strong><br><code>scipy.stats</code> 模块包含了统计学函数，用于执行各种统计分析。</p>
</li>
<li><p><strong>积分（Integration）：</strong><br><code>scipy.integrate</code> 模块提供了积分函数，用于数值积分和微分方程求解。</p>
</li>
<li><p><strong>图像处理（Image Processing）：</strong><br><code>scipy.ndimage</code> 模块包含了用于图像处理的函数，如滤波、形态学操作等。</p>
</li>
<li><p><strong>稀疏矩阵（Sparse Matrix）：</strong><br><code>scipy.sparse</code> 模块提供了用于处理大规模稀疏矩阵的工具，包括线性代数操作。</p>
</li>
<li><p><strong>空间距离（Spatial distance）：</strong><br><code>scipy.spatial</code> 模块包含了用于计算空间距离的函数，如距离矩阵的计算等。</p>
</li>
</ol>
<p>以上只是 <code>SciPy</code> 的一些功能模块，它还包括其他一些子模块，每个子模块都提供了一组相关的工具和算法。通过结合 <code>NumPy</code> 和 <code>SciPy</code>，你可以进行更广泛领域的科学计算和数据分析。</p>
<h3><span id="3数值计算可视化库matplotlib">3.数值计算可视化库matplotlib</span></h3><p><code>matplotlib</code> 是一个用于绘制二维图形的强大可视化库，主要用于数据可视化、绘制图表和图形等。它支持多种绘图风格，可以用于创建线图、散点图、柱状图、饼图等各种图表类型。以下是一些 <code>matplotlib</code> 的基本用法和功能：</p>
<ol>
<li><p><strong>导入 matplotlib：</strong><br>在使用 matplotlib 之前，需要导入它：</p>
<pre><code class="python">import matplotlib.pyplot as plt
</code></pre>
<p>通常使用 <code>plt</code> 作为别名。</p>
</li>
<li><p><strong>绘制简单的线图：</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt

# 创建数据
x = [1, 2, 3, 4, 5]
y = [2, 4, 6, 8, 10]

# 绘制线图
plt.plot(x, y)

# 显示图形
plt.show()
</code></pre>
</li>
<li><p><strong>散点图：</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt

# 创建数据
x = [1, 2, 3, 4, 5]
y = [2, 4, 6, 8, 10]

# 绘制散点图
plt.scatter(x, y)

# 显示图形
plt.show()
</code></pre>
</li>
<li><p><strong>柱状图：</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt

# 创建数据
categories = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]
values = [3, 7, 2, 5]

# 绘制柱状图
plt.bar(categories, values)

# 显示图形
plt.show()
</code></pre>
</li>
<li><p><strong>饼图：</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt

# 创建数据
sizes = [25, 30, 20, 25]
labels = [&#39;Category A&#39;, &#39;Category B&#39;, &#39;Category C&#39;, &#39;Category D&#39;]

# 绘制饼图
plt.pie(sizes, labels=labels, autopct=&#39;%1.1f%%&#39;)

# 显示图形
plt.show()
</code></pre>
</li>
</ol>
<p>这只是 <code>matplotlib</code> 的一小部分功能，它还支持自定义图表样式、添加标签、网格线等。<code>matplotlib</code> 可以与 <code>NumPy</code> 和 <code>SciPy</code> 结合使用，以实现更复杂的数据分析和可视化任务。</p>

            
        </div>
    </div>
-->
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/python/" style="color: #00a596">python</a>
        </span>
        
    </div>

<!--
    <span class="icon">
        <i class="fa-solid fa-tags fa-fw"></i>
    </span>

    <span class="date">
        <span class="icon">
            <i class="fa-solid fa-calendar fa-fw"></i>
        </span>
        2024/3/31
    </span>
-->
    <a href="/2024/03/31/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="go-post">阅读全文</a>

</div>

<div class="post">
    <a href="/2024/03/31/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/">
        <h2 class="post-title">你好，世界</h2>
    </a>



    <div class="category-and-date">

        


        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/31
        </span>



        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
        </div>
    </div>
<!--
    <div class="description">
        <div class="content" v-pre>
            
            <h1><span id="halo-wadoru">halo wadoru!!!</span></h1><p>Hello, world!</p>
<p>¡Hola, mundo!</p>
<p>Bonjour, monde !</p>
<p>Hallo Welt!</p>
<p>Ciao, mondo!</p>
<p>Olá, mundo!</p>
<p>你好，世界！</p>
<p>こんにちは、世界！</p>
<p>안녕하세요, 세계!</p>
<p>Привет, мир!</p>
<p>مرحباً بالعالم!</p>
<p>नमस्ते दुनिया!</p>
<p>হ্যালো, বিশ্ব!</p>
<p>Merhaba, dünya!</p>
<p>Hallo, wereld!</p>
<p>Γειά σου, κόσμε!</p>
<p>Hej, världen!</p>
<p>Witaj, świecie!</p>
<p>Chào bạn, thế giới!</p>
<p>สวัสดี, โลก!</p>
<pre><code class="python">print(&quot;Hello, World!&quot;)
</code></pre>
<pre><code class="javascript">console.log(&quot;Hello, World!&quot;);
</code></pre>
<pre><code class="java">public class HelloWorld &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello, World!&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="c">#include &lt;stdio.h&gt;

int main() &#123;
    printf(&quot;Hello, World!\n&quot;);
    return 0;
&#125;
</code></pre>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<pre><code class="ruby">puts &quot;Hello, World!&quot;
</code></pre>
<pre><code class="swift">print(&quot;Hello, World!&quot;)
</code></pre>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    fmt.Println(&quot;Hello, World!&quot;)
&#125;
</code></pre>
<pre><code class="rust">fn main() &#123;
    println!(&quot;Hello, World!&quot;);
&#125;
</code></pre>
<pre><code class="php">&lt;?php
echo &quot;Hello, World!&quot;;
?&gt;
</code></pre>

            
        </div>
    </div>
-->
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/hello-world/" style="color: #ffa2c4">hello world</a>
        </span>
        
    </div>

<!--
    <span class="icon">
        <i class="fa-solid fa-tags fa-fw"></i>
    </span>

    <span class="date">
        <span class="icon">
            <i class="fa-solid fa-calendar fa-fw"></i>
        </span>
        2024/3/31
    </span>
-->
    <a href="/2024/03/31/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/" class="go-post">阅读全文</a>

</div>

<div class="post">
    <a href="/2024/03/31/Rust/">
        <h2 class="post-title">Rust学习</h2>
    </a>



    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                基础知识
            </a>
        </span>

        


        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/31
        </span>



        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
        </div>
    </div>
<!--
    <div class="description">
        <div class="content" v-pre>
            
            <h3><span id="入门rust算是比其他语言要难一些">入门rust算是比其他语言要难一些</span></h3><p>所有权机制明显地区分了rust和C++、Java</p>
<p>rust实现链表操作简直地狱</p>
<p>这就不得不提到<a target="_blank" rel="noopener" href="https://course.rs/about-book.html">rust圣经</a>，感谢前辈们的努力！</p>
<hr>
<p>附烂梗一则<del>bushi</del></p>
<pre><code class="xiaochou">今天在网吧看到一个妹妹很可爱，走近一看竟然在写代码。
我大喜过望，想和她一起写，就坐了过去。
妹妹人也特别好，一直和我在聊天，讨论各种语言的特点。
然后她突然要和我一起写代码。
我才发现这个妹妹写的都是 Rust、Haskell、Lisp 这种高端语言。
我看着我的 C++ 冷汗直冒，一直不敢新建项目。
妹妹看到我的窘迫很温柔地问我：
是不是写的 C，没关系的，语法简单但是上限也不低，
写 C 的程序员都很懂计算机系统和结构。
我一听更不敢说话了，
妹妹看我没说话又说没事没事：
写 Java 也没什么的，毕竟做大型项目能力不俗。
见我还没反应，她的表情突然有点尴尬地笑了笑问我：
该不会是写 Python 的吧，虽然语言一般但是生态很好，
一起做做数据分析也没什么。
我只好告诉她我写的是 C++，她的脸色唰一下就变了：
“我说你怎么不敢说话，原来是写 C++ 的。” 
她看了我的代码之后，眼神中的鄙视更深了一层。
“写 C++，还用 C with Class？
别的语言一个都没用过？
C++ 码农真下头！滚，别坐我旁边，看着都恶心！”
</code></pre>
<p><img src="/../image/420126789964089224.jpg" alt="image"></p>

            
        </div>
    </div>
-->
    <div class="post-tags">
        
        
        
    </div>

<!--
    <span class="icon">
        <i class="fa-solid fa-tags fa-fw"></i>
    </span>

    <span class="date">
        <span class="icon">
            <i class="fa-solid fa-calendar fa-fw"></i>
        </span>
        2024/3/31
    </span>
-->
    <a href="/2024/03/31/Rust/" class="go-post">阅读全文</a>

</div>




        <div class="page-current">
    
    <a class="page-num" href="/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">2</span>
    
    <a class="page-num" href="/page/3">3</a>
    
    
    
    
    <a class="page-num" href="/page/3/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>
    </div>



    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">ailasukasan</div>
        <div class="description">
            <p>你好，我是来自北大软微的一名学生<br><a target="_blank" rel="noopener" href="https://www.ss.pku.edu.cn/">北京大學軟件與微電子學院</a><br>軟件工程專業<br>こんにちは<br>僕は北大ソフトウェア工学の学生です<br>a student from Peking University of<br>Software and Microelectronics</p>

            <hr>
            <p><a target="_blank" rel="noopener" href="https://github.com/ailasukasan">我的GitHub主页</a><br>虽然啥也没有…万一以后想用呢？</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 PHM&#39;s world
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;ailasukasan
        </div>
        <div>
            可以点击一下Try Try <a target="_blank" rel="noopener" href="https://github.com/ailasukasan">歡迎來到我的世界</a> &amp;
            <a href="">站在能分割世界的桥</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>


        
    </div>
    <script src="/js/main.js"></script>
    


</body>
</html>
