



<!DOCTYPE html>
<html lang="en">
<head>

<!--
    <script src="/js/leaves.js"></script>
-->
    <!-- 爆炸红心效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.9' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--流星雨背景
<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
-->
    <meta charset="utf-8" />
    <title>C++实现高性能服务器框架(3) | PHM&#39;s world</title>
    <meta name="author" content="ailasukasan" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>歡迎來到烏托邦的世界</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>PHM&#39;S WORLD</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;PHM</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;PHM&#39;S WORLD</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">PHM</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>C++实现高性能服务器框架(3)</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/5/31
        </span>
        
        <span class="category">
            <a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                服务器开发
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/C/" style="color: #ffa2c4">C++</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1><span id="c实现高性能服务器3-线程与协程">C++实现高性能服务器（3）—-线程与协程</span></h1><h1><span id="一线程模块">一，线程模块</span></h1><ul>
<li>封装了一些常用的锁机制（信号量、互斥锁、自旋锁、读写锁），确保线程安全</li>
<li>对pthread系列函数封装，生成Thread类</li>
</ul>
<p>该模块基于<code>pthread</code>实现。sylar说，由于c++11中的thread也是由pthread封装实现的，并且没有提供读写互斥量，读写锁，自旋锁等，所以自己封装了pthread。</p>
<p>锁模块实现了信号量、互斥量、读写锁、自旋锁、原子锁的封装</p>
<ul>
<li><strong>class Semaphore</strong>：信号量封装</li>
<li><strong>class Mutex</strong>：互斥量封装</li>
<li><strong>class RWMutex</strong>：读写锁封装</li>
<li><strong>class Spinlock</strong>：自旋锁封装</li>
<li><strong>class CASLock</strong>：原子锁封装</li>
</ul>
<p>线程模块主要由Thread类实现</p>
<ul>
<li><strong>class Thread</strong>：实现线程的封装</li>
</ul>
<p>关于线程id的问题，在获取线程id时使用syscall获得唯一的线程id</p>
<pre><code class="cpp">css复制代码进程pid: getpid()                 
线程tid: pthread_self()     //进程内唯一，但是在不同进程则不唯一。
线程pid: syscall(SYS_gettid)     //系统内是唯一的
</code></pre>
<h4><span id="lock">Lock</span></h4><ul>
<li>一些常用的锁机制，包括信号量<code>SemaphoreLock</code>、互斥锁<code>Mutex</code>、自旋锁<code>SpinLock</code>、读写锁<code>RWMutex</code></li>
<li>RAII模式，构造时lock，析构时unlcok</li>
</ul>
<pre><code class="cpp"> //局部锁
template&lt;class T&gt;
class ScopedLockImpl &#123;
 public:
     //构造函数，自动加锁
     ScopedLockImpl(T&amp; mutex)
         :m_mutex(mutex) &#123;
         lock();
     &#125;

     //析构函数，自动解锁
     ~ScopedLockImpl() &#123;     
         unlock();
     &#125;

     void lock() &#123;
         if (!m_locked) &#123;
             m_mutex.lock();
             m_locked = true;
         &#125;
     &#125;

     void unlock() &#123;
         if (m_locked) &#123;
             m_mutex.unlock();   
             m_locked = false;
         &#125;
     &#125;
     
 private:
     T&amp; m_mutex;
     bool m_locked = false;
 &#125;;
</code></pre>
<h3><span id="thread">Thread</span></h3><ul>
<li>线程模块，主要是对pthread的封装</li>
</ul>
<pre><code class="cpp">class Thread : Noncopyable
&#123;
public:
    typedef std::shared_ptr&lt;Thread&gt; ptr;

    /**
     * @brief 构造函数
     * @param[in] cb 线程执行函数
     * @param[in] name 线程名称
     */
    Thread(std::function&lt;void()&gt; cb, const std::string&amp; name);
    ~Thread();
    void join();				// 等待线程执行完成
    static Thread* GetThis();	// 获取当前的线程指针

    // get set 方法

private:
    static void* run(void* arg);	// 线程执行函数 	
private:	
    pid_t m_id = -1;				// 线程id
    std::string m_name;				// 线程名称
    pthread_t m_thread = 0;			// 线程
    std::function&lt;void()&gt; m_cb;		// 线程执行函数
    SemaphoreLock m_semaphore;		// 信号量
&#125;;
</code></pre>
<ul>
<li>线程的入口函数，只支持void(void)类型的入口函数，不支持给线程传参数，但实际使用时可以结合std::bind来绑定参数，这样就相当于支持任何类型和数量的参数。</li>
</ul>
<pre><code class="cpp">std::function&lt;void()&gt; m_cb;		// 线程执行函数
</code></pre>
<ul>
<li>因为我们是在线程执行函数中完成一些成员变量的初始化，因此在Thread的构造函数中，应当使用信号量（V操作），保证在构造完成之前已经执行了线程执行函数（入口函数中P操作）。</li>
</ul>
<pre><code class="cpp">// 构造函数
Thread::Thread(std::function&lt;void()&gt; cb, const std::string&amp; name)
        : m_cb(cb)
        , m_name(name)
&#123;
    if (name.empty())
    &#123;
        m_name = &quot;UNKNOW&quot;;
    &#125;
    int rt = pthread_create(&amp;m_thread, nullptr, &amp;Thread::run, this);
    if (rt) &#123;
        LOG_ERROR(g_logger) &lt;&lt; &quot;pthread_create thread fail, rt=&quot; &lt;&lt; rt
            &lt;&lt; &quot; name=&quot; &lt;&lt; name;
        throw std::logic_error(&quot;pthread_create error&quot;);
    &#125;

    //等待，直到创建出的线程开始执行，run()
    m_semaphore.wait();
&#125;

// 线程执行函数
void* Thread::run(void* arg) &#123;
    Thread* thread = (Thread*)arg;
    t_thread = thread;
    t_thread_name = thread-&gt;m_name;
    thread-&gt;m_id = johnsonli::getThreadId();
    pthread_setname_np(pthread_self(), thread-&gt;m_name.substr(0, 15).c_str());

    std::function&lt;void()&gt; cb;
    cb.swap(thread-&gt;m_cb);

    //线程初始化完成后，就唤醒 Thread()，完成构造
    thread-&gt;m_semaphore.notify();

    cb();
    return 0;
&#125;
</code></pre>
<p>同时也保证了在构造完成之后线程函数一定已经处于运行状态</p>
<ul>
<li>局部线程静态变量，表示当前正在执行的线程。声明为<code>static thread_local</code></li>
</ul>
<pre><code class="cpp">// thread.cpp
// 局部线程静态变量，只在当前线程有用
// 当前运行的线程
static thread_local Thread* t_thread = nullptr;
</code></pre>
<p>在线程执行函数<code>run</code>中，会完成初始化，此后在线程入口函数<code>m_cb</code>中就可以调用静态方法<code>GetThis</code>获得当前线程</p>
<pre><code class="cpp">// thread.h
static Thread* GetThis()

// thread.cpp
Thread* Thread::GetThis() &#123;
    return t_thread;
&#125;

// main.cpp
void fun1()
&#123;
    // 线程入口函数中获取当前线程
    LOG_INFO(g_logger) &lt;&lt; &quot; this.name: &quot; &lt;&lt; Thread::GetThis()-&gt;getName();
&#125;

Thread::ptr thr(new johnsonli::Thread(&amp;fun1, &quot;name&quot;));
</code></pre>
<h1><span id="二协程模块">二，协程模块</span></h1><p>1.每个协程在创建时都会指定一个入口函数，类似线程。协程的本质就是函数和函数运行状态的组合。<br>2.在普通函数中，函数一旦被调用，只能从头开始执行，直到函数执行结束退出；协程可以执行一半就退出（call），但并未真正结束，只是暂时让出CPU执行权，之后可以恢复运行（back）。在暂停运行期间，其他协程可以获得CPU并运行，因此协程也称为轻量级线程。<br>3.本协程模块时基于ucontext_t实现，也就是协程上下文，包含了函数在当前执行状态下的全部CPU寄存器的值（函数栈帧，代码执行位置等），具体信息如下所示</p>
<h3><span id="1-主要功能">1. 主要功能</span></h3><ul>
<li>使用非对称协程模型，简化程序逻辑</li>
<li>由用户控制协程的执行逻辑，实现了主协程与子协程间的自由切换</li>
<li>每个线程有一个主协程t_threadFiber，由主协程创建子协程，通过call()进入子协程运行，back()退出子协程，返回主协程</li>
</ul>
<p><strong>为什么要使用协程？</strong></p>
<p>从了解进程，线程，协程之间的区别开始。</p>
<ol>
<li>从定义来看<ul>
<li>进程是资源分配和拥有的基本单位。进程通过内存映射拥有独立的代码和数据空间，若没有内存映射给进程独立的空间，则没有进程的概念了。</li>
<li>线程是程序执行的基本单位。线程都处在一个进程空间中，可以相互访问，没有限制，所以使用线程进行多任务变成十分便利，所以当一个线程崩溃，其他任何一个线程都不能幸免。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</li>
<li>协程是用户态的轻量级线程，线程内部调度的基本单位。协程在线程上执行。</li>
</ul>
</li>
<li>从系统调用来看<ul>
<li>进程由操作系统进行切换，会在用户态与内核态之间来回切换。在切换进程时需要切换虚拟内存空间，切换页表，切换内核栈以及硬件上下文等，开销非常大。</li>
<li>线程由操作系统进行切换，会在用户态与内核态之间来回切换。在切换线程时需要保存和设置少量寄存器内容，开销很小。</li>
<li>协程由用户进行切换，并不会陷入内核态。先将寄存器上下文和栈保存，等切换回来的时候再进行恢复，上下文的切换非常快</li>
</ul>
</li>
<li>从并发性来看<ul>
<li>不同进程之间切换实现并发，各自占有CPU实现并行</li>
<li>一个进程内部的多个线程并发执行</li>
<li>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</li>
</ul>
</li>
</ol>
<p>通过协程，我们可以让程序按照我们的想法去运行，而不是从头到尾的执行下去。例如我们在执行一个函数时，可以通过<code>yield</code>退出，让出当前的CPU执行权，等到了合适的时候，通过<code>resume</code>重新恢复运行。</p>
<p>因为协程是在单线程上运行的，并不是并发执行的，是顺序执行的，所以不能使用锁来做协程的同步，这样会直接导致线程的死锁。</p>
<h2><span id="实现思路">实现思路</span></h2><p>使用非对称协程的设计思路，通过主协程创建新协程，主协程由<code>swapIn()</code>让出执行权执行子协程的任务，子协程可以通过<code>YieldToHold()</code>让出执行权继续执行主协程的任务，不能在子协程之间做相互的转化，这样会导致回不到<code>main</code>函数的上下文。这里使用了两个线程局部变量保存当前协程和主协程，切换协程时调用<code>swapcontext</code>，若两个变量都保存子协程，则无法回到原来的主协程中。</p>
<pre><code class="css">css复制代码Fiber::GetThis() 获得主协程
                  swapIn()        
Thread-&gt;man_fiber --------&gt; sub_fiber (new(Fiber(cb)))
            ^
            | Fiber::YieldToHold()
            |
         sub_fiber
</code></pre>
<h2><span id="class-fiber协程模块"><em>class</em> Fiber（协程模块）</span></h2><pre><code class="arduino">arduino复制代码// 用于生成协程id
static std::atomic&lt;uint64_t&gt; s_fiber_id &#123;0&#125;;
// 用于统计当前的协程数
static std::atomic&lt;uint64_t&gt; s_fiber_count &#123;0&#125;;

// 约定协程栈的大小1MB
static ConfigVar&lt;uint32_t&gt;::ptr g_fiber_stack_size =
    Config::Lookup&lt;uint32_t&gt;(&quot;fiber.stack_size&quot;, 1024 * 1024, &quot;fiber stack size&quot;);

// 当前协程
static thread_local Fiber *t_fiber = nullptr;
// 主协程
static thread_local Fiber::ptr t_threadFiber = nullptr;
</code></pre>
<ul>
<li>创建&#x2F;释放协程运行栈</li>
</ul>
<pre><code class="arduino">arduino复制代码class MallocStackAllocator &#123;
public:
    static void* Alloc(size_t size) &#123;
        return malloc(size);
    &#125;

    static void Dealloc(void* vp, size_t size) &#123;
        return free(vp);
    &#125;
&#125;;

using StackAllocator = MallocStackAllocator;
</code></pre>
<ul>
<li>协程有五种状态</li>
</ul>
<pre><code class="arduino">arduino复制代码enum State
&#123;
    // 初始化
    INIT,
    // 暂停
    HOLD,
    // 执行
    EXEC,
    // 结束
    TERM,
    // 可执行
    READY,
    // 异常
    EXCEPT
&#125;;
</code></pre>
<h3><span id="mumber成员变量">mumber（成员变量）</span></h3><pre><code class="arduino">arduino复制代码// 协程id
uint64_t m_id = 0;
// 协程运行栈大小
uint32_t m_stacksize = 0;
// 协程状态
State m_state = INIT;
// 上下文
ucontext_t m_ctx;
// 协程运行栈指针
void* m_stack = nullptr;
// 协程执行方法
std::function&lt;void()&gt; m_cb;
</code></pre>
<h3><span id="fiber构造函数">Fiber（构造函数）</span></h3><ul>
<li><strong>private无参构造</strong></li>
</ul>
<p>主协程的构造</p>
<pre><code class="scss">scss复制代码Fiber::Fiber() &#123;
    m_state = EXEC;
    // 设置当前协程
    SetThis(this);
    // 获取当前协程的上下文信息保存到m_ctx中
    if (getcontext(&amp;m_ctx)) &#123;
        SYLAR_ASSERT2(false, &quot;getcontext&quot;);
    &#125;

    ++s_fiber_count;

    SYLAR_LOG_DEBUG(g_logger)  &lt;&lt; &quot;Fiber::Fiber(root)&quot;;
&#125;
</code></pre>
<ul>
<li><strong>public有参构造</strong></li>
</ul>
<p>子协程的构造</p>
<pre><code class="scss">scss复制代码Fiber::Fiber(std::function&lt;void()&gt; cb, size_t stacksize, bool use_caller)
    :m_id(s_fiber_count)
    ,m_cb(cb)&#123;
    ++s_fiber_count;
    // 若给了初始化值则用给定值，若没有则用约定值
    m_stacksize = stacksize ? stacksize : g_fiber_stack_size-&gt;getValue();
    
    // 获得协程运行指针
    m_stack = StackAllocator::Alloc(m_stacksize);
    // 保存当前协程上下文信息到m_ctx中
    if (getcontext(&amp;m_ctx)) &#123;
        SYLAR_ASSERT2(false, &quot;getcontext&quot;);
    &#125;
    // uc_link为空，执行完当前context之后退出程序。
    m_ctx.uc_link = nullptr;
    // 初始化栈指针
    m_ctx.uc_stack.ss_sp = m_stack;
    // 初始化栈大小
    m_ctx.uc_stack.ss_size = m_stacksize;
    
    // 指明该context入口函数
    if (!use_caller) &#123;
        makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, 0);
    &#125; else &#123;
        makecontext(&amp;m_ctx, &amp;Fiber::CallerMainFunc, 0);
    &#125;
    
    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;Fiber::Fiber id = &quot; &lt;&lt; m_id;
&#125;
</code></pre>
<h3><span id="~fiber析构函数">~Fiber（析构函数）</span></h3><p>释放协程运行栈</p>
<pre><code class="scss">scss复制代码Fiber::~Fiber() &#123;
    --s_fiber_count;
    // 子协程
    if (m_stack) &#123;
        // 不在准备和运行状态
        SYLAR_ASSERT(m_state == TERM || m_state == INIT || m_state == EXCEPT);
        // 释放运行栈
        StackAllocator::Dealloc(m_stack, m_stacksize);
    &#125; else &#123;
         // 主协程的释放要保证没有任务并且当前正在运行
        SYLAR_ASSERT(!m_cb);
        SYLAR_ASSERT(m_state == EXEC);
        //若当前协程为主协程，将当前协程置为空
        Fiber *cur = t_fiber;
        if (cur == this) &#123;
            SetThis(nullptr);
        &#125;
    &#125;
    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;Fiber::~Fiber id = &quot; &lt;&lt; m_id;
&#125;
</code></pre>
<h3><span id="reset重置协程">reset（重置协程）</span></h3><pre><code class="ini">ini复制代码void Fiber::reset(std::function&lt;void()&gt; cb) &#123;
    // 主协程不分配栈
    SYLAR_ASSERT(m_stack);
    // 当前协程不在准备和运行态
    SYLAR_ASSERT(m_state == INIT || m_state == TERM || m_state == EXCEPT);
    m_cb = cb;
    if (getcontext(&amp;m_ctx)) &#123;
        SYLAR_ASSERT2(false, &quot;getcontext&quot;);
    &#125;
    m_ctx.uc_link = nullptr;
    m_ctx.uc_stack.ss_sp = m_stack;
    m_ctx.uc_stack.ss_size = m_stacksize;

    makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, 0);
    m_state = INIT;
&#125;
</code></pre>
<h3><span id="call-swapin切换到当前协程">call、swapIn（切换到当前协程）</span></h3><pre><code class="scss">scss复制代码// 从协程主协程切换到当前协程
void Fiber::call() &#123;
    SetThis(this);
    m_state = EXEC;
    if (swapcontext(&amp;t_threadFiber-&gt;m_ctx, &amp;m_ctx)) &#123;
        SYLAR_ASSERT2(false, &quot;swapIn_context&quot;);
    &#125;
&#125;
// 从调度器的主协程切换到当前协程
void Fiber::swapIn() &#123;
    SetThis(this);
    SYLAR_ASSERT(m_state != EXEC);
    m_state = EXEC;

    if (swapcontext(&amp;Scheduler::GetMainFiber()-&gt;m_ctx, &amp;m_ctx)) &#123;
        SYLAR_ASSERT2(false, &quot;swapIn_context&quot;);
    &#125;
&#125;
</code></pre>
<h3><span id="back-swapout当前协程切换到后台">back、swapOut（当前协程切换到后台）</span></h3><pre><code class="scss">scss复制代码// 从当前协程切换到主协程
void Fiber::back() &#123;
    SetThis(t_threadFiber.get());
    if (swapcontext(&amp;m_ctx, &amp;t_threadFiber-&gt;m_ctx)) &#123;
        SYLAR_ASSERT2(false, &quot;swapcontext&quot;);
    &#125;
&#125;
// 从当前协程切换到调度器主协程
void Fiber::swapOut() &#123;
    SetThis(Scheduler::GetMainFiber());
    // SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;change fiber with&quot; &lt;&lt; Scheduler::GetMainFiber()-&gt;GetFiberId();

    if (swapcontext(&amp;m_ctx, &amp;Scheduler::GetMainFiber()-&gt;m_ctx)) &#123;
        SYLAR_ASSERT2(false, &quot;swapcontext&quot;);
    &#125;
&#125;
</code></pre>
<h3><span id="setthis设置当前协程">SetThis（设置当前协程）</span></h3><pre><code class="ini">ini复制代码void Fiber::SetThis(Fiber* f) &#123;
    t_fiber = f;
&#125;
</code></pre>
<h3><span id="getthis返回当前协程并获得主协程">GetThis（返回当前协程并获得主协程）</span></h3><pre><code class="scss">scss复制代码Fiber::ptr Fiber::GetThis() &#123;
    // 返回当前协程
    if (t_fiber) &#123;
        return t_fiber-&gt;shared_from_this();
    &#125;
    // 获得主协程
    Fiber::ptr main_fiber(new Fiber);
    // 此时当前协程应该为主协程
    SYLAR_ASSERT(main_fiber.get() == t_fiber);
    t_threadFiber = main_fiber;

    return t_fiber-&gt;shared_from_this();
&#125;
</code></pre>
<h3><span id="yieldtoready协程切换到后台-并且设置为ready状态">YieldToReady（协程切换到后台， 并且设置为Ready状态）</span></h3><pre><code class="ini">ini复制代码void Fiber::YieldToReady() &#123;
    Fiber::ptr cur = GetThis();
    cur-&gt;m_state = READY;
    cur-&gt;swapOut();
&#125;
</code></pre>
<h3><span id="yieldtohold协程切换到后台-并且设置为hold状态">YieldToHold（协程切换到后台， 并且设置为Hold状态）</span></h3><pre><code class="ini">ini复制代码void Fiber::YieldToHold() &#123;
    Fiber::ptr cur = GetThis();
    cur-&gt;m_state = HOLD;
    cur-&gt;swapOut();
&#125;
</code></pre>
<h3><span id="mainfunc协程执行函数">MainFunc（协程执行函数）</span></h3><pre><code class="rust">rust复制代码void Fiber::MainFunc() &#123;
    // 获得当前协程
    Fiber::ptr cur = GetThis();
    SYLAR_ASSERT(cur);
    try &#123;
        // 执行任务
        cur-&gt;m_cb();
        cur-&gt;m_cb = nullptr;
        // 将状态设置为结束
        cur-&gt;m_state = TERM;
    &#125; catch (std::exception &amp;ex) &#123;
        cur-&gt;m_state = EXCEPT;
        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;Fiber Except: &quot; &lt;&lt; ex.what()
                                  &lt;&lt; std::endl
                                  &lt;&lt; &quot; fiber_id = &quot; &lt;&lt; cur-&gt;getId()
                                  &lt;&lt; std::endl
                                  &lt;&lt; sylar::BacktraceToString();
    &#125;
    catch (...)
    &#123;
        cur-&gt;m_state = EXCEPT;
        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;Fiber Except: &quot;
                                  &lt;&lt; std::endl
                                  &lt;&lt; &quot; fiber_id = &quot; &lt;&lt; cur-&gt;getId()
                                  &lt;&lt; std::endl
                                  &lt;&lt; sylar::BacktraceToString();
    &#125;
    
    // 获得裸指针
    auto raw_ptr = cur.get();
    // 引用-1，防止fiber释放不掉
    cur.reset();
    //执行完释放执行权
    raw_ptr-&gt;swapOut();

    SYLAR_ASSERT2(false, &quot;never reach fiber_id = &quot; + std::to_string(raw_ptr-&gt;getId()));
&#125;

void Fiber::CallerMainFunc() &#123;
    Fiber::ptr cur = GetThis();
    SYLAR_ASSERT(cur);
    try &#123;
        cur-&gt;m_cb();
        cur-&gt;m_cb = nullptr;
        cur-&gt;m_state = TERM;
    &#125; catch (std::exception &amp;ex) &#123;
        cur-&gt;m_state = EXCEPT;
        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;Fiber Except: &quot; &lt;&lt; ex.what()
                                  &lt;&lt; std::endl
                                  &lt;&lt; &quot; fiber_id = &quot; &lt;&lt; cur-&gt;getId()
                                  &lt;&lt; std::endl
                                  &lt;&lt; sylar::BacktraceToString();
    &#125;
    catch (...)
    &#123;
        cur-&gt;m_state = EXCEPT;
        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;Fiber Except: &quot;
                                  &lt;&lt; std::endl
                                  &lt;&lt; &quot; fiber_id = &quot; &lt;&lt; cur-&gt;getId()
                                  &lt;&lt; std::endl
                                  &lt;&lt; sylar::BacktraceToString();
    &#125;

    auto raw_ptr = cur.get();
    cur.reset();
    raw_ptr-&gt;back();

    SYLAR_ASSERT2(false, &quot;never reach fiber_id = &quot; + std::to_string(raw_ptr-&gt;getId()));
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 PHM&#39;s world
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;ailasukasan
        </div>
        <div>
            可以点击一下Try Try <a target="_blank" rel="noopener" href="https://github.com/ailasukasan">歡迎來到我的世界</a> &amp;
            <a href="">站在能分割世界的桥</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>


        
    </div>
    <script src="/js/main.js"></script>
    
    




    


</body>
</html>
