



<!DOCTYPE html>
<html lang="en">
<head>

<!--
    <script src="/js/leaves.js"></script>
-->
    <!-- 爆炸红心效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.9' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--流星雨背景
<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
-->
    <meta charset="utf-8" />
    <title>自旋锁 | PHM&#39;s world</title>
    <meta name="author" content="ailasukasan" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>歡迎來到烏托邦的世界</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>PHM&#39;S WORLD</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;PHM</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;PHM&#39;S WORLD</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">PHM</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>自旋锁</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/5/15
        </span>
        
        <span class="category">
            <a href="/categories/%E5%9F%BA%E7%A1%80/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                基础
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E9%94%81/" style="color: #ffa2c4">锁</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1><span id="自旋锁">自旋锁</span></h1><p>自旋锁是一种用于多线程编程的同步机制，其特点是当一个线程试图获取锁而锁已经被其他线程持有时，这个线程会不断地循环检查锁的状态（即“自旋”），直到获取到锁为止。自旋锁避免了线程在等待锁时被操作系统挂起，从而减少了上下文切换的开销，但也因此会占用CPU资源。自旋锁在短期锁定的情况下是高效的，但在锁定时间较长的情况下可能导致性能下降。</p>
<p>示例：</p>
<pre><code class="cpp">#include &lt;atomic&gt;
#include &lt;thread&gt;

class SpinLock &#123;
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT;

public:
    void lock() &#123;
        // 自旋直到成功获取锁
        while (flag.test_and_set(std::memory_order_acquire)) &#123;
            // 在等待的过程中可以选择加入一些操作，
            // 比如让出CPU资源给其他线程
            std::this_thread::yield();
        &#125;
    &#125;

    void unlock() &#123;
        // 释放锁
        flag.clear(std::memory_order_release);
    &#125;
&#125;;

// 示例使用
SpinLock spinLock;

void critical_section() &#123;
    spinLock.lock();
    // 在临界区进行操作
    // ...
    spinLock.unlock();
&#125;

int main() &#123;
    std::thread t1(critical_section);
    std::thread t2(critical_section);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>上述例子中<code>SpinLock</code> 类使用了 <code>std::atomic_flag</code> 来实现自旋锁。<code>lock</code> 方法通过 <code>test_and_set</code> 方法不断尝试设置标志位，当其他线程释放锁时（即 <code>flag.clear</code>），标志位会被清除，此时 <code>test_and_set</code> 将返回 <code>false</code>，当前线程成功获取锁。<code>unlock</code> 方法则通过 <code>clear</code> 方法释放锁。</p>
<p>自旋锁适用于锁持有时间非常短的情况，因为自旋会占用CPU资源。如果锁持有时间较长，使用互斥量（如 <code>std::mutex</code>）更合适。</p>
<p>以下情况使用自旋锁合适：</p>
<p>1.临界区代码执行时间非常短：自旋锁最适合用于锁定时间极短的临界区。例如，临界区内只是进行一些简单的变量更新或快速检查。因为自旋锁在等待锁释放期间会一直占用CPU，如果临界区代码执行时间较长，自旋锁会导致CPU资源浪费，降低系统整体性能。</p>
<p>2.低锁争用的场景：在多线程程序中，如果锁的争用较低，即大多数情况下锁是可用的，自旋锁的性能会比较好。因为在这种情况下，线程很少需要自旋等待，大部分时间可以直接获取锁。</p>
<p>3.线程数量较少的情况：当程序中的线程数量较少时，自旋锁的效率会更高，因为线程间的竞争较少，线程在自旋时对CPU资源的争夺不会太激烈。</p>
<p>4.嵌入式系统或实时系统：在某些嵌入式系统或实时系统中，线程上下文切换的开销非常高，而自旋锁可以避免这种开销，从而在某些特定场景中提高系统的实时性和响应速度。</p>
<p>5.没有操作系统内核支持的环境：在某些裸机编程或者没有操作系统内核支持的环境中，自旋锁是唯一的选择，没有其他同步机制可以使用。</p>
<p>比如：<br>全局计数器，多个线程需要对这个计数器进行并发的递增操作。由于递增操作非常短暂，自旋锁在这个场景下是一个合适的选择。</p>
<pre><code class="cpp">#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

// 自旋锁类
class SpinLock &#123;
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT;

public:
    void lock() &#123;
        while (flag.test_and_set(std::memory_order_acquire)) &#123;
            std::this_thread::yield(); // 让出CPU资源
        &#125;
    &#125;

    void unlock() &#123;
        flag.clear(std::memory_order_release);
    &#125;
&#125;;

// 全局计数器和自旋锁
int counter = 0;
SpinLock spinLock;

void increment_counter(int iterations) &#123;
    for (int i = 0; i &lt; iterations; ++i) &#123;
        spinLock.lock();
        ++counter;  // 临界区
        spinLock.unlock();
    &#125;
&#125;

int main() &#123;
    const int num_threads = 10;
    const int iterations = 1000;

    // 创建并启动线程
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; num_threads; ++i) &#123;
        threads.emplace_back(increment_counter, iterations);
    &#125;

    // 等待所有线程完成
    for (auto&amp; t : threads) &#123;
        t.join();
    &#125;

    // 输出结果
    std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; counter &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p>需要注意的是，自旋锁通常不提供公平性（即等待时间长的线程不一定先获取锁），这可能导致某些线程长时间得不到锁，自旋锁可能带来线程饥饿的问题。</p>
<p><strong>线程饥饿：</strong>（Thread Starvation）是指某些线程长时间无法获得所需的资源（如锁），导致这些线程无法正常执行或完成任务的现象。这通常是由于资源被其他线程长期占用或优先级机制不合理所导致的。在多线程编程中，线程饥饿可能会导致系统性能下降甚至死锁等严重问题。</p>
<p>但依旧要使用自旋锁的时候，可以使用线程队列来解决，例如：</p>
<pre><code class="cpp">#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;

class FairSpinLock &#123;
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT;
    std::mutex mtx;
    std::condition_variable cv;
    std::queue&lt;std::thread::id&gt; waitQueue;

public:
    void lock() &#123;
        std::thread::id this_id = std::this_thread::get_id();
        &#123;
            std::lock_guard&lt;std::mutex&gt; lock(mtx);
            waitQueue.push(this_id);
        &#125;

        while (true) &#123;
            if (waitQueue.front() == this_id &amp;&amp; !flag.test_and_set(std::memory_order_acquire)) &#123;
                std::lock_guard&lt;std::mutex&gt; lock(mtx);
                waitQueue.pop();
                return;
            &#125;
            std::this_thread::yield();  // 让出CPU资源
        &#125;
    &#125;

    void unlock() &#123;
        flag.clear(std::memory_order_release);
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        cv.notify_all();
    &#125;
&#125;;

int counter = 0;
FairSpinLock fairSpinLock;

void increment_counter() &#123;
    for (int i = 0; i &lt; 100; ++i) &#123;
        fairSpinLock.lock();
        ++counter;
        std::this_thread::sleep_for(std::chrono::milliseconds(10)); // 模拟长时间的临界区
        fairSpinLock.unlock();
    &#125;
&#125;

int main() &#123;
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 10; ++i) &#123;
        threads.emplace_back(increment_counter);
    &#125;

    for (auto&amp; t : threads) &#123;
        t.join();
    &#125;

    std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; counter &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 PHM&#39;s world
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;ailasukasan
        </div>
        <div>
            可以点击一下Try Try <a target="_blank" rel="noopener" href="https://github.com/ailasukasan">歡迎來到我的世界</a> &amp;
            <a href="">站在能分割世界的桥</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>


        
    </div>
    <script src="/js/main.js"></script>
    
    




    


</body>
</html>
