



<!DOCTYPE html>
<html lang="en">
<head>

<!--
    <script src="/js/leaves.js"></script>
-->
    <!-- 爆炸红心效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.9' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--流星雨背景
<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
-->
    <meta charset="utf-8" />
    <title>Python学习笔记 | PHM&#39;s world</title>
    <meta name="author" content="ailasukasan" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>歡迎來到烏托邦的世界</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>PHM&#39;S WORLD</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;PHM</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;PHM&#39;S WORLD</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">PHM</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Python学习笔记</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/31
        </span>
        
        <span class="category">
            <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                基础知识
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/python/" style="color: #03a9f4">python</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1><span id="python">Python</span></h1><p>[TOC]</p>
<h2><span id="一编程前的准备工作">一.编程前的准备工作</span></h2><p>在命令行（bash）中打开 Python 和运行 Python 文件的步骤如下：</p>
<h3><span id="1-打开-python-解释器">1. 打开 Python 解释器</span></h3><p>在命令行中输入以下命令并按回车键：</p>
<pre><code>python
</code></pre>
<p>这将启动 Python 解释器，你将看到一个提示符 <code>&gt;&gt;&gt;</code>，表示你可以在这里输入 Python 代码并执行。</p>
<h3><span id="2-运行-python-文件">2. 运行 Python 文件</span></h3><p>在命令提示符（cmd.exe）中，你无需输入 <code>python</code> 或 <code>python3</code>，而是直接输入以下命令：</p>
<pre><code>test.py
</code></pre>
<p>确保你的命令提示符的当前工作目录是包含 <code>test.py</code> 文件的目录，或者你可以提供文件的完整路径。这样应该可以成功运行 <code>test.py</code> 文件。</p>
<p>可以使用 <code>cd</code> 命令切换到包含 <code>test.py</code> 文件的目录，然后再运行 <code>test.py</code>。例如：</p>
<pre><code>cd path\to\your\script\directory
test.py
</code></pre>
<p>这里的 <code>path\to\your\script\directory</code> 是包含 <code>test.py</code> 文件的目录的路径。</p>
<p>如果你知道 <code>test.py</code> 文件的绝对路径，也可以直接在命令提示符中输入：</p>
<pre><code>path\to\test.py
</code></pre>
<h2><span id="二python的语言基础">二.Python的语言基础</span></h2><h3><span id="1type函数">1.type()函数：</span></h3><p>在交互模式下得到参数的数据类型</p>
<h3><span id="2-乘方-幂运算">2. 乘方 ，幂运算</span></h3><h3><span id="3eval函数">3.eval()函数：</span></h3><p><code>eval()</code> 函数是一个内置函数，它用于动态地执行字符串表达式，并返回表达式的结果。这个函数接受一个字符串参数，该字符串包含有效的Python表达式，然后执行该表达式并返回结果。</p>
<p>语法：</p>
<pre><code class="python">eval(expression, globals=None, locals=None)
</code></pre>
<ul>
<li><code>expression</code>: 要执行的字符串表达式。</li>
<li><code>globals</code>（可选）: 一个字典，用于全局命名空间的变量。如果提供了 <code>globals</code> 参数，那么 <code>eval()</code> 函数将在这个字典的上下文中执行表达式。</li>
<li><code>locals</code>（可选）: 一个字典，用于局部命名空间的变量。如果提供了 <code>locals</code> 参数，那么 <code>eval()</code> 函数将在这个字典的上下文中执行表达式。</li>
</ul>
<p>使用 <code>eval()</code> 的例子：</p>
<pre><code class="python">x = 10
y = 20
result = eval(&#39;x + y&#39;)
print(result)  # 输出 30
</code></pre>
<p>在这个例子中，<code>eval(&#39;x + y&#39;)</code> 执行了字符串表达式 <code>&#39;x + y&#39;</code>，并返回结果 <code>30</code>。</p>
<p>需要注意的是，<code>eval()</code> 函数具有潜在的安全风险，因为它允许执行任意的Python代码。如果从不受信任的来源获取字符串并将其传递给 <code>eval()</code>，可能会导致安全问题。因此，应该谨慎使用 <code>eval()</code>，特别是在处理用户输入时。</p>
<h3><span id="4input函数">4.input()函数：</span></h3><p>获取用户输入的数据，input() 内可以放双引号””来添加内容。</p>
<h3><span id="5格式化字符串format">5.格式化字符串format():</span></h3><p><code>format()</code> 方法是用于格式化字符串的内置方法。它允许你通过将占位符 <code>&#123;&#125;</code> 插入字符串中，并使用 <code>format()</code> 方法提供的参数替换这些占位符。</p>
<p>基本的语法如下：</p>
<pre><code class="python">formatted_string = &quot;Some text with &#123;&#125; and &#123;&#125;&quot;.format(value1, value2)
</code></pre>
<p>这里的 <code>&#123;&#125;</code> 是占位符，它们会依次被 <code>format()</code> 方法的参数替换。可以有多个占位符，也可以使用序号或关键字来指定替换的值。</p>
<p>例子：</p>
<pre><code class="python">name = &quot;John&quot;
age = 30
# 使用位置参数
formatted_string = &quot;My name is &#123;&#125; and I am &#123;&#125; years old.&quot;.format(name, age)
print(formatted_string)
# 输出: My name is John and I am 30 years old.
</code></pre>
<pre><code class="python"># 使用序号指定顺序
formatted_string = &quot;&#123;1&#125; is &#123;0&#125; years old.&quot;.format(age, name)
print(formatted_string)
# 输出: John is 30 years old.
</code></pre>
<pre><code class="python"># 使用关键字参数
formatted_string = &quot;My name is &#123;n&#125; and I am &#123;a&#125; years old.&quot;.format(n=name, a=age)
print(formatted_string)
# 输出: My name is John and I am 30 years old.
</code></pre>
<p><code>format()</code> 方法还支持更复杂的格式设置，包括指定字段宽度、精度、填充字符等。以下是一个简单的例子：</p>
<pre><code class="python">pi = 3.1415926535

# 指定小数点后两位
formatted_string = &quot;The value of pi is &#123;:.2f&#125;&quot;.format(pi)
print(formatted_string)
# 输出: The value of pi is 3.14
</code></pre>
<p>这些只是 <code>format()</code> 方法的一些基础用法，详细的格式化选项可以查阅 Python 官方文档。</p>
<h3><span id="6续行符号">6.续行符号\</span></h3><pre><code class="python">print(&quot;我是一名程序员\
我刚开始学习python&quot;)
</code></pre>
<h3><span id="7print函数">7.print()函数</span></h3><pre><code class="python">for i in range(1, 10):
    for j in range(1, i+1):
        product = i * j
        print(f&quot;&#123;j&#125; * &#123;i&#125; = &#123;product&#125;\t&quot;, end=&quot;&quot;)
    print()
</code></pre>
<h4><span id="1默认换行">（1）默认换行</span></h4><p><strong>在Python中，<code>print()</code> 函数默认在打印完内容之后会添加一个换行符（<code>\n</code>）</strong>，从而使下一个输出跳到新的一行。这是因为在Python 3中，<code>print()</code> 函数有一个默认的 <code>end</code> 参数，其默认值为 <code>\n</code>，表示在输出结束时要添加的字符串。</p>
<p>例如：</p>
<pre><code class="python">print(&quot;Hello&quot;)
print(&quot;World&quot;)
</code></pre>
<p>这段代码的输出将是：</p>
<pre><code>Hello
World
</code></pre>
<p>如果你想自定义 <code>end</code> 参数，可以在 <code>print()</code> 函数中指定，比如：</p>
<pre><code class="python">print(&quot;Hello&quot;, end=&quot;***&quot;)
print(&quot;World&quot;)
</code></pre>
<p>这样的输出将是：</p>
<pre><code>Hello***World
</code></pre>
<p>但通常情况下，我们使用 <code>print()</code> 函数时不需要显式指定 <code>end</code> 参数，因为默认的换行符对于大多数情况都是合适的。</p>
<h4><span id="2格式化输出">（2）格式化输出</span></h4><p>在这个语句中，<code>f&quot;&#123;j&#125; * &#123;i&#125; = &#123;product&#125;\t&quot;</code> 使用了 f-string（格式化字符串字面值）。f-string 是在 Python 3.6 版本中引入的一种方便的字符串格式化方式。</p>
<p>在一个 f-string 中，你可以在字符串中嵌入表达式，这些表达式会在运行时被求值，并将结果插入到字符串中。在这里，<code>&#123;j&#125;</code>, <code>&#123;i&#125;</code>, <code>&#123;product&#125;</code> 都是表达式，分别代表变量 <code>j</code>、<code>i</code> 和 <code>product</code> 的值。<code>\t</code> 表示制表符，用于在输出中产生水平间距。</p>
<p>这样的语法使得字符串的构建更加清晰和简便，而不需要使用传统的字符串连接方式。例子中的 f-string 被用于构建乘法口诀表中每行的输出。</p>
<h2><span id="三小海龟turtle">三.小海龟Turtle</span></h2><h3><span id="1基本操作">1.基本操作</span></h3><pre><code class="python">import turtle
turtle.forward(200)
turtle.done() #结束绘制工作
turtle.left(90) #向左旋转90度
turtle.color(&quot;red&quot;)
#上色：
turtle.color(&quot;yellow&quot;)
turtle.begin_fill()
turtle.end_fill()
#背景
turtle.bgcolor(&quot;black&quot;)
#移动开始位置
turtle.up()
turtle.goto(100,100)
turtle.down()
</code></pre>
<h3><span id="2循环">2.循环</span></h3><pre><code class="python">for i in range(4): #先记住
    turtle.forward(200)
    turtle.left(90)
</code></pre>
<h2><span id="四程序的流程控制">四，程序的流程控制</span></h2><h3><span id="1基本内容">1.基本内容</span></h3><p>if else</p>
<p>elif</p>
<p>while</p>
<p>for</p>
<h3><span id="2循环中的else">2.循环中的else</span></h3><p>python中特有，循环中可以有else分支</p>
<p>可以使用while或者for</p>
<pre><code class="python">str = input()
for letter in str:
    print(letter,end = &quot; &quot;)
else:
    print(&quot;循环正常结束&quot;)
print(&quot;程序结束&quot;)
</code></pre>
<h2><span id="五函数与模块">五，函数与模块</span></h2><h3><span id="1匿名函数">1.匿名函数</span></h3><p>仅包含一条语句，参数可有可无，参数个数任意</p>
<pre><code class="python">s = lambda : &quot;python&quot;.upper()
f = lambda x : x*10
print(s())
print(f(10))
</code></pre>
<h3><span id="2默认参数与关键字参数">2.默认参数与关键字参数</span></h3><p>在Python中，函数的参数可以分为两种：默认参数和关键字参数。</p>
<ol>
<li><p><strong>默认参数（Default Parameters）：</strong></p>
<p>默认参数是在定义函数时给参数一个默认值，如果在调用函数时没有传递该参数，则使用默认值。定义默认参数的语法是在函数定义中给参数赋予默认值。</p>
<p>示例：</p>
<pre><code class="python">def greet(name, greeting=&quot;Hello&quot;):
    print(f&quot;&#123;greeting&#125;, &#123;name&#125;!&quot;)

greet(&quot;Alice&quot;)  # 使用默认值输出：Hello, Alice!
greet(&quot;Bob&quot;, &quot;Good morning&quot;)  # 使用传递的值输出：Good morning, Bob!
</code></pre>
<p>在这个例子中，<code>greeting</code> 参数有一个默认值 “Hello”，如果不提供该参数，将使用默认值。</p>
</li>
<li><p><strong>关键字参数（Keyword Arguments）：</strong></p>
<p>关键字参数是通过指定参数名进行传递的参数。在函数调用中，通过 <code>parameter_name=value</code> 的形式传递参数，这样可以不按照函数定义时的参数顺序传递。</p>
<p>示例：</p>
<pre><code class="python">def display_info(name, age, city):
    print(f&quot;Name: &#123;name&#125;, Age: &#123;age&#125;, City: &#123;city&#125;&quot;)

display_info(age=25, name=&quot;Alice&quot;, city=&quot;Wonderland&quot;)
</code></pre>
<p>在这个例子中，通过关键字参数指定了参数的值，顺序可以与函数定义时不同。</p>
</li>
</ol>
<p>注意事项：</p>
<ul>
<li>默认参数必须在非默认参数之后定义，例如 <code>def func(param1, param2=default_value):</code>。</li>
<li>如果同时使用默认参数和关键字参数，关键字参数必须位于默认参数之后。</li>
</ul>
<h3><span id="3不定长参数">3.不定长参数</span></h3><p>在Python中，有两种不定长参数的方式：可变位置参数和可变关键字参数。</p>
<ol>
<li><p><strong>可变位置参数（*args）：</strong></p>
<p>可变位置参数允许你传递任意数量的位置参数给函数。在函数定义时，在参数前面加上 <code>*</code> 号，这表示接受任意数量的位置参数，并将它们作为元组传递给函数。</p>
<p>示例：</p>
<pre><code class="python">def print_args(*args):
    for arg in args:
        print(arg)

print_args(1, 2, 3, &quot;four&quot;)
</code></pre>
<p>这个函数接受任意数量的参数，并将它们打印出来。</p>
</li>
<li><p><strong>可变关键字参数（</strong>kwargs）：**</p>
<p>可变关键字参数允许你传递任意数量的关键字参数给函数。在函数定义时，在参数前面加上 <code>**</code> 号，这表示接受任意数量的关键字参数，并将它们作为字典传递给函数。</p>
<p>示例：</p>
<pre><code class="python">def print_kwargs(**kwargs):
    for key, value in kwargs.items():
        print(f&quot;&#123;key&#125;: &#123;value&#125;&quot;)

print_kwargs(name=&quot;Alice&quot;, age=25, city=&quot;Wonderland&quot;)
</code></pre>
<p>这个函数接受任意数量的关键字参数，并将它们打印出来。</p>
</li>
</ol>
<p>使用时，你可以同时使用这两种不定长参数，例如：</p>
<pre><code class="python">def example_function(arg1, *args, kwarg1=&quot;default&quot;, **kwargs):
    # 函数体
    pass
</code></pre>
<p>这个函数可以接受一个位置参数 <code>arg1</code>，任意数量的位置参数 <code>args</code>，一个默认值的关键字参数 <code>kwarg1</code>，和任意数量的关键字参数 <code>kwargs</code>。</p>
<h3><span id="4模块化程序设计">4.模块化程序设计</span></h3><h4><span id="1基础知识">(1)基础知识</span></h4><p>一个或几个.py相关的函数保存为.py文件，构成一个模块，导入该模块，可以调用模块中定义的函数</p>
<p>在Python中，你可以将几个不同的函数打包为一个模块。以下是一个简单的步骤：</p>
<ol>
<li><p><strong>创建一个新的Python文件：</strong> 为你的模块选择一个名称，并创建一个以<code>.py</code>为扩展名的新文件，例如<code>mymodule.py</code>。</p>
</li>
<li><p><strong>在文件中定义函数：</strong> 在新文件中，定义你想要包含的函数。例如：</p>
<pre><code class="python"># mymodule.py

def add_numbers(a, b):
    return a + b

def multiply_numbers(a, b):
    return a * b

def greet(name):
    return f&quot;Hello, &#123;name&#125;!&quot;
</code></pre>
</li>
<li><p><strong>保存文件：</strong> 保存你的文件。</p>
</li>
<li><p><strong>在其他Python文件中使用模块：</strong> 你可以在其他Python文件中使用你创建的模块。例如，如果你的模块文件和使用模块的文件在同一目录下，可以这样使用：</p>
<pre><code class="python"># 使用模块的文件
  
import mymodule
  
result = mymodule.add_numbers(3, 4)
print(result)
  
greeting = mymodule.greet(&quot;John&quot;)
print(greeting)
</code></pre>
<p>如果模块文件不在同一目录下，你可以将模块文件所在的路径添加到Python解释器的搜索路径中，或者使用相对路径导入模块。</p>
</li>
</ol>
<p>通过这种方式，你可以将多个函数组织在一个模块中，使代码更易于管理和维护。</p>
<p>如果模块文件不在同一目录下，你可以使用以下方法导入模块：</p>
<p>假设有以下目录结构：</p>
<pre><code>project/
|-- modules/
|   |-- mymodule.py
|-- main.py
</code></pre>
<ol>
<li><p><strong>添加模块所在路径到sys.path：</strong></p>
<p>在<code>main.py</code>文件中，你可以使用<code>sys.path</code>添加模块所在的路径。确保你的<code>main.py</code>文件中包含以下代码：</p>
<pre><code class="python"># main.py

import sys
sys.path.append(&quot;path/to/modules&quot;)

import mymodule

result = mymodule.add_numbers(3, 4)
print(result)

greeting = mymodule.greet(&quot;John&quot;)
print(greeting)
</code></pre>
<p>将<code>&quot;path/to/modules&quot;</code>替换为<code>mymodule.py</code>所在的实际路径。</p>
</li>
<li><p><strong>使用相对路径导入：</strong></p>
<p>如果<code>main.py</code>和<code>mymodule.py</code>在相对位置上有固定的相对路径，你可以使用相对导入。例如，如果<code>main.py</code>和<code>mymodule.py</code>在同一目录下，可以这样导入：</p>
<pre><code class="python"># main.py

from modules import mymodule

result = mymodule.add_numbers(3, 4)
print(result)

greeting = mymodule.greet(&quot;John&quot;)
print(greeting)
</code></pre>
<p>如果<code>main.py</code>在<code>project</code>目录下，你可以使用<code>from modules import mymodule</code>。</p>
</li>
</ol>
<p>选择适合你项目结构的方法，并确保你正确引入了模块。</p>
<h4><span id="2模块及其引用">(2)模块及其引用</span></h4><p>在Python中，有几种不同的模块引用方法，具体取决于模块的位置和你希望如何引用它。以下是一些常见的模块引用方法：</p>
<ol>
<li><p><strong>绝对路径引用：</strong></p>
<p>如果模块在Python解释器的搜索路径中，你可以使用绝对路径引用。这是最基本的引用方式。</p>
<pre><code class="python"># 使用绝对路径引用
import mymodule
</code></pre>
</li>
<li><p><strong>相对路径引用：</strong></p>
<p>如果你的模块和使用它的脚本在相同目录下或有固定的相对路径关系，可以使用相对路径引用。</p>
<pre><code class="python"># 使用相对路径引用
from . import mymodule  # 当脚本和模块在同一目录下
</code></pre>
</li>
<li><p><strong>添加路径到sys.path：</strong></p>
<p>通过将模块所在路径添加到<code>sys.path</code>，你可以使用绝对或相对引用。</p>
<pre><code class="python"># 添加路径到sys.path
import sys
sys.path.append(&quot;path/to/modules&quot;)

import mymodule
</code></pre>
</li>
<li><p><strong>包引用：</strong></p>
<p>如果你的模块在一个包（目录）中，你可以使用包引用。</p>
<pre><code class="python"># 包引用
from mypackage import mymodule
</code></pre>
<p>这假设<code>mymodule</code>是<code>mypackage</code>包中的一个模块。</p>
</li>
<li><p><strong>别名引用：</strong></p>
<p>你还可以为模块使用别名，使代码更简洁。</p>
<pre><code class="python"># 使用别名引用
import mymodule as mm
</code></pre>
<p>然后，你可以使用 <code>mm</code> 来代替 <code>mymodule</code>。</p>
</li>
</ol>
<p>选择适合你项目结构和需求的引用方法，并确保你的模块路径正确。</p>
<p>在Python中，<code>sys.path</code>是一个包含用于查找模块的目录路径的列表。这个列表由解释器在启动时设置，它包括了以下几个元素：</p>
<ol>
<li>当前工作目录（Current Working Directory）。</li>
<li>PYTHONPATH 环境变量中指定的目录。</li>
<li>内置模块的默认路径。</li>
<li>在安装 Python 时配置的默认路径。</li>
</ol>
<p><code>sys.path</code>中的目录路径按照它们在列表中的顺序进行搜索。当你导入一个模块时，Python 解释器会按照这个路径列表的顺序在这些目录中查找相应的模块文件。</p>
<p>你可以通过在代码中修改 <code>sys.path</code> 来添加或删除目录路径，以影响模块的搜索路径。例如，你可以使用 <code>sys.path.append(&quot;path/to/directory&quot;)</code> 将目录添加到搜索路径中。</p>
<p>以下是一个简单的示例，演示了 <code>sys.path</code> 的基本用法：</p>
<pre><code class="python">import sys

# 输出当前 sys.path
print(&quot;Current sys.path:&quot;, sys.path)

# 添加一个目录到 sys.path
sys.path.append(&quot;/path/to/custom/directory&quot;)

# 再次输出 sys.path
print(&quot;Updated sys.path:&quot;, sys.path)
</code></pre>
<p>通过了解 <code>sys.path</code>，你可以更好地理解 Python 解释器在哪里查找模块文件。这对于处理模块的导入和路径问题非常有用。</p>
<h4><span id="3包">(3)包</span></h4><p>在Python中，包（Package）是一种将模块组织在一起的方式，以便更好地管理和组织代码。包本质上是一个包含了特殊文件 <code>__init__.py</code> 的目录，该目录下可以包含其他模块或子包。</p>
<p>以下是创建和引用Python包的基本步骤：</p>
<h3><span id="建立包">建立包：</span></h3><ol>
<li><p><strong>创建包目录：</strong> 创建一个目录，该目录将作为包的顶级目录。</p>
<pre><code>mypackage/
</code></pre>
</li>
<li><p><strong>在包目录中添加 <code>__init__.py</code> 文件：</strong> 添加一个空的 <code>__init__.py</code> 文件，它会告诉Python这个目录应该被视为一个包。</p>
<pre><code>mypackage/
├── __init__.py
</code></pre>
</li>
<li><p><strong>在包中添加模块文件：</strong> 在包目录中添加模块文件，可以是以<code>.py</code>为扩展名的Python文件。</p>
<pre><code>mypackage/
├── __init__.py
├── module1.py
├── module2.py
</code></pre>
<pre><code class="python"># module1.py
def function1():
    print(&quot;Function 1 in module1&quot;)

# module2.py
def function2():
    print(&quot;Function 2 in module2&quot;)
</code></pre>
</li>
</ol>
<h3><span id="引用包中的模块">引用包中的模块：</span></h3><ol>
<li><p><strong>绝对路径引用：</strong> 使用绝对路径引用包中的模块。</p>
<pre><code class="python"># main.py
from mypackage import module1, module2

module1.function1()
module2.function2()
</code></pre>
</li>
<li><p><strong>相对路径引用：</strong> 在包内的模块之间进行相对路径引用。</p>
<pre><code class="python"># module1.py
from .module2 import function2

def function1():
    print(&quot;Function 1 in module1&quot;)
    function2()
</code></pre>
</li>
<li><p><strong>导入整个包：</strong> 你也可以导入整个包，然后使用点符号访问模块。</p>
<pre><code class="python"># main.py
import mypackage

mypackage.module1.function1()
mypackage.module2.function2()
</code></pre>
</li>
</ol>
<p>通过这些步骤，你可以创建和引用Python包，从而更好地组织和管理你的代码。</p>
<h4><span id="4内置函数">(4)内置函数</span></h4><p>Python 3中有许多内置函数，这些函数不需要导入任何模块即可使用。以下是一些常用的Python 3内置函数：</p>
<ol>
<li><p><strong>类型转换函数：</strong></p>
<ul>
<li><code>int(x [, base])</code>: 将x转换为一个整数。<code>base</code> 参数指定 x 中的数字是什么进制，默认是十进制。</li>
<li><code>float(x)</code>: 将 x 转换为一个浮点数。</li>
<li><code>str(x)</code>: 将对象 x 转换为字符串。</li>
</ul>
</li>
<li><p><strong>序列操作函数：</strong></p>
<ul>
<li><code>len(sequence)</code>: 返回序列的长度。</li>
<li><code>max(iterable, *[, key, default])</code>: 返回可迭代对象中的最大值。</li>
<li><code>min(iterable, *[, key, default])</code>: 返回可迭代对象中的最小值.</li>
<li><code>sum(iterable, /, start=0)</code>: 返回可迭代对象中所有元素的总和。</li>
</ul>
</li>
<li><p><strong>迭代器和生成器函数：</strong></p>
<ul>
<li><code>iter(object[, sentinel])</code>: 返回一个迭代器对象。</li>
<li><code>next(iterator[, default])</code>: 从迭代器中获取下一个元素。</li>
<li><code>range(stop)</code>, <code>range(start, stop[, step])</code>: 创建一个范围内的数字序列。</li>
</ul>
</li>
<li><p><strong>其他常用函数：</strong></p>
<ul>
<li><code>print(*objects, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</code>: 打印输出。</li>
<li><code>input([prompt])</code>: 从用户获取输入。</li>
<li><code>type(object)</code>: 返回对象的类型。</li>
<li><code>len(object)</code>: 返回对象的长度。</li>
</ul>
</li>
<li><p><strong>数学函数：</strong></p>
<ul>
<li><code>abs(x)</code>: 返回 x 的绝对值。</li>
<li><code>pow(x, y[, z])</code>: 返回 x 的 y 次方，如果给定 z 参数，返回 x 的 y 次方与 z 取模的结果。</li>
</ul>
</li>
</ol>
<p>以上仅是一小部分Python 3内置函数，实际上Python提供了很多有用的内置函数。你可以查阅官方文档或使用 <code>help()</code> 函数来获取更多关于内置函数的信息。</p>
<h2><span id="六数据结构">六，数据结构</span></h2><h3><span id="1元组">1.元组</span></h3><p>就是只读列表</p>
<p>用（）来表示</p>
<p>在Python中，元组是不可变的数据结构，这意味着一旦创建，就不能对其进行修改。因此，删除元组的操作实际上是删除整个元组对象的引用。你不能删除元组中的单个元素，但可以删除整个元组变量。</p>
<p>删除整个元组变量：</p>
<p>使用 <code>del</code> 关键字可以删除整个元组变量。</p>
<pre><code class="python">my_tuple = (1, 2, 3, 4, 5)

# 删除整个元组变量
del my_tuple

# 尝试访问已删除的元组会引发异常
# print(my_tuple)  # 这行代码会引发 NameError
</code></pre>
<p>在上述示例中，<code>del my_tuple</code> 删除了整个元组对象。</p>
<p>删除元组中的元素（不可行）：</p>
<p>由于元组是不可变的，不能删除元组中的单个元素。如果需要删除某个元素，你可能需要考虑使用其他数据结构，如列表（list）。</p>
<pre><code class="python">my_list = [1, 2, 3, 4, 5]

# 删除列表中的元素
del my_list[2]

print(my_list)  # 输出: [1, 2, 4, 5]
</code></pre>
<p>总的来说，元组是不可变的，因此不能直接删除其中的元素。你只能删除整个元组变量。如果你需要对元素进行增删操作，可能需要使用列表等可变的数据结构。</p>
<h3><span id="2列表">2.列表</span></h3><p>列表中可以存放多个元素的值，可以修改或者删除</p>
<p>在Python中，列表（List）是一种可变的数据结构，允许你在创建后对其进行修改。以下是一些常用的列表数据操作方法：</p>
<h4><span id="创建列表">创建列表：</span></h4><pre><code class="python">my_list = [1, 2, 3, 4, 5]
</code></pre>
<h4><span id="访问元素">访问元素：</span></h4><pre><code class="python"># 访问单个元素
first_element = my_list[0]

# 访问多个元素（切片）
subset = my_list[1:4]  # 包含索引 1、2、3的元素
</code></pre>
<h4><span id="修改元素">修改元素：</span></h4><pre><code class="python"># 修改单个元素
my_list[2] = 10

# 修改多个元素（切片赋值）
my_list[1:4] = [20, 30, 40]
</code></pre>
<h4><span id="添加元素">添加元素：</span></h4><pre><code class="python"># 在末尾添加一个元素
my_list.append(6)

# 在指定位置插入一个元素
my_list.insert(2, 15)
</code></pre>
<h4><span id="删除元素">删除元素：</span></h4><pre><code class="python"># 删除指定位置的元素
del my_list[2]

# 删除指定值的第一个匹配项
my_list.remove(30)

# 弹出（删除并返回）指定位置的元素
popped_element = my_list.pop(1)
</code></pre>
<h4><span id="查找元素">查找元素：</span></h4><pre><code class="python"># 查找元素的索引
index = my_list.index(4)
</code></pre>
<h4><span id="其他常用方法">其他常用方法：</span></h4><pre><code class="python"># 获取列表长度
length = len(my_list)

# 排序列表（原地排序）
my_list.sort()

# 反向排序列表（原地操作）
my_list.reverse()

# 复制列表
copy_of_list = my_list.copy()

# 清空列表
my_list.clear()
</code></pre>
<p>以上是一些基本的列表数据操作方法。列表提供了很多灵活的操作，使得对数据的处理变得非常方便。</p>
<p>列表中的pop操作默认删除列表的最后一个元素</p>
<pre><code class="python">number = [1,2,3]
number.pop()
</code></pre>
<p>remove方法移除列表中的某个元素的第一个匹配项</p>
<pre><code>char.remove(&quot;d&quot;)
</code></pre>
<h3><span id="3字符串">3.字符串</span></h3><h4><span id="字符串的截取">字符串的截取</span></h4><pre><code class="python">var = &quot;hello&quot;
var[0]
#得到的结果是h
</code></pre>
<h4><span id="连接字符串">连接字符串</span></h4><pre><code class="python">var1 = &#39;hello&#39;
var2 = &#39;python&#39;
var1 = var1 + var2
print(var1)
#hellopython
</code></pre>
<h4><span id="格式化字符串">格式化字符串</span></h4><p>在Python中，格式化字符串是一种方便的方法，用于创建包含变量或表达式值的字符串。主要有以下几种方式：</p>
<ol>
<li><p><strong>百分比（%）格式化</strong>：这是一种较早的格式化方式。它使用 <code>%</code> 操作符和一个格式字符串。</p>
<pre><code class="python">name = &quot;Alice&quot;
age = 30
formatted_string = &quot;Hello, %s. You are %d years old.&quot; % (name, age)
</code></pre>
</li>
<li><p><strong><code>str.format()</code> 方法</strong>：这是一种更现代的格式化方法，提供了更多的灵活性。</p>
<pre><code class="python">name = &quot;Alice&quot;
age = 30
formatted_string = &quot;Hello, &#123;&#125;. You are &#123;&#125; years old.&quot;.format(name, age)
</code></pre>
<p>你也可以使用索引或关键字来更明确地指定格式化值的位置：</p>
<pre><code class="python">formatted_string = &quot;Hello, &#123;1&#125;. You are &#123;0&#125; years old.&quot;.format(age, name)
</code></pre>
</li>
<li><p><strong>f-字符串（自Python 3.6起可用）</strong>：这是最新且通常最推荐的格式化方法。它非常直观和易读。</p>
<pre><code class="python">name = &quot;Alice&quot;
age = 30
formatted_string = f&quot;Hello, &#123;name&#125;. You are &#123;age&#125; years old.&quot;
</code></pre>
</li>
</ol>
<p>在这些方法中，f-字符串因其简洁和直观而成为许多Python开发者的首选。它允许直接在字符串中插入变量和表达式。</p>
<h4><span id="字符串的操作方法">字符串的操作方法</span></h4><p>在Python中，<code>find()</code> 和 <code>join()</code> 是字符串操作的两个常用方法。</p>
<ol>
<li><p><strong><code>find()</code> 方法：</strong></p>
<ul>
<li><code>find()</code> 方法用于在字符串中查找子字符串，并返回第一个匹配的位置。如果找不到匹配的子字符串，则返回 -1。</li>
<li>语法：<code>str.find(sub[, start[, end]])</code><ul>
<li><code>sub</code> 是要查找的子字符串。</li>
<li><code>start</code> 是可选参数，指定开始查找的位置，默认为 0。</li>
<li><code>end</code> 是可选参数，指定结束查找的位置，默认为字符串的长度。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="python">sentence = &quot;Hello, how are you?&quot;
position = sentence.find(&quot;how&quot;)
print(position)  # 输出: 7
</code></pre>
</li>
<li><p><strong><code>join()</code> 方法：</strong></p>
<ul>
<li><code>join()</code> 方法用于将序列中的元素以指定的字符串连接生成一个新的字符串。</li>
<li>语法：<code>str.join(iterable)</code><ul>
<li><code>str</code> 是连接的字符串。</li>
<li><code>iterable</code> 是一个可迭代对象，如列表、元组等。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="python">words = [&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;]
result = &quot; &quot;.join(words)
print(result)  # 输出: Hello world !
</code></pre>
</li>
</ol>
<p>这两个方法在处理字符串时非常实用。<code>find()</code> 用于查找子字符串的位置，而 <code>join()</code> 用于将多个字符串连接在一起。</p>
<p>在Python中，<code>split()</code> 和 <code>strip()</code> 是两个用于字符串操作的常用方法。</p>
<ol>
<li><p><strong><code>split()</code> 方法：</strong></p>
<ul>
<li><code>split()</code> 方法用于将字符串分割成一个列表，通过指定分隔符。默认情况下，它使用空格作为分隔符。</li>
<li>语法：<code>str.split([sep[, maxsplit]])</code><ul>
<li><code>sep</code> 是可选参数，指定分隔符，默认为空格。</li>
<li><code>maxsplit</code> 是可选参数，指定分割的最大次数。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="python">sentence = &quot;Hello, how are you?&quot;
words = sentence.split()  # 默认以空格分割
print(words)  # 输出: [&#39;Hello,&#39;, &#39;how&#39;, &#39;are&#39;, &#39;you?&#39;]
</code></pre>
<p>也可以指定其他分隔符：</p>
<pre><code class="python">data = &quot;apple,orange,banana&quot;
fruits = data.split(&#39;,&#39;)
print(fruits)  # 输出: [&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;]
</code></pre>
</li>
<li><p><strong><code>strip()</code> 方法：</strong></p>
<ul>
<li><code>strip()</code> 方法用于去除字符串两端的空白字符（包括空格、制表符和换行符）。</li>
<li>语法：<code>str.strip([chars])</code><ul>
<li><code>chars</code> 是可选参数，指定要去除的字符，默认为去除空白字符。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="python">text = &quot;   This is a sentence.   &quot;
stripped_text = text.strip()
print(stripped_text)  # 输出: &#39;This is a sentence.&#39;
</code></pre>
<p>也可以指定要去除的特定字符：</p>
<pre><code class="python">text = &quot;!!!This is important!!!&quot;
stripped_text = text.strip(&#39;!&#39;)
print(stripped_text)  # 输出: &#39;This is important&#39;
</code></pre>
</li>
</ol>
<p>这两个方法在字符串处理中非常有用，<code>split()</code> 用于拆分字符串，而 <code>strip()</code> 用于去除字符串两端的空白字符或指定字符。</p>
<p>lower()  upper()方法</p>
<p>小写&#x2F;大写字母</p>
<h4><span id="in方法">in方法</span></h4><pre><code>var = &#39;hee&#39;
&#39;e&#39; in var
#返回true
</code></pre>
<h3><span id="4字典">4.字典</span></h3><p>是python中的唯一映射类型</p>
<p>在Python中，字典（Dictionary）是一种无序、可变的数据类型，用于存储键-值对。以下是字典的创建和访问字典中的值的方法：</p>
<ol>
<li><p><strong>字典的创建：</strong></p>
<ul>
<li><p>使用花括号 <code>&#123;&#125;</code> 创建字典，其中每个键值对用冒号 <code>:</code> 分隔，键和值之间用逗号 <code>,</code> 分隔。</p>
</li>
<li><p>例如：</p>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;
</code></pre>
</li>
<li><p>通过 <code>dict()</code> 构造函数也可以创建字典：</p>
<pre><code class="python">another_dict = dict(name=&quot;Alice&quot;, age=25, city=&quot;London&quot;)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>访问字典中的值：</strong></p>
<ul>
<li><p>使用键来访问字典中的值。通过指定键，可以获取相应的值。</p>
</li>
<li><p>例如：</p>
<pre><code class="python">print(my_dict[&quot;name&quot;])  # 输出: John
print(another_dict[&quot;age&quot;])  # 输出: 25
</code></pre>
</li>
<li><p>使用 <code>get()</code> 方法也可以访问值，如果键不存在，不会引发错误，而是返回一个默认值（默认为 <code>None</code>）：</p>
<pre><code class="python">print(my_dict.get(&quot;city&quot;))  # 输出: New York
print(my_dict.get(&quot;gender&quot;, &quot;Not specified&quot;))  # 输出: Not specified (因为 &quot;gender&quot; 不存在)
</code></pre>
</li>
<li><p>使用 <code>keys()</code> 方法可以获取所有的键，而 <code>values()</code> 方法可以获取所有的值：</p>
<pre><code class="python">keys = my_dict.keys()
values = my_dict.values()
print(keys)  # 输出: dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;city&#39;])
print(values)  # 输出: dict_values([&#39;John&#39;, 30, &#39;New York&#39;])
</code></pre>
</li>
</ul>
</li>
</ol>
<p>这些方法使得字典在存储和检索键值对时非常方便。字典中的键是唯一的，而值可以是任何数据类型。</p>
<p>在Python中，可以使用不同的方法来修改字典中的数据，包括添加新的键值对、更新现有的键值对以及删除键值对。</p>
<ol>
<li><p><strong>添加新的键值对：</strong></p>
<ul>
<li>可以通过指定新的键和相应的值，向字典中添加新的键值对。</li>
</ul>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;

# 添加新的键值对
my_dict[&quot;gender&quot;] = &quot;Male&quot;
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;, &#39;gender&#39;: &#39;Male&#39;&#125;
</code></pre>
</li>
<li><p><strong>更新现有的键值对：</strong></p>
<ul>
<li>可以通过指定已有的键来更新对应的值。</li>
</ul>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;

# 更新现有的键值对
my_dict[&quot;age&quot;] = 31
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 31, &#39;city&#39;: &#39;New York&#39;&#125;
</code></pre>
<ul>
<li>使用 <code>update()</code> 方法也可以一次性更新多个键值对。</li>
</ul>
<pre><code class="python">my_dict.update(&#123;&quot;age&quot;: 32, &quot;country&quot;: &quot;USA&quot;&#125;)
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 32, &#39;city&#39;: &#39;New York&#39;, &#39;country&#39;: &#39;USA&#39;&#125;
</code></pre>
</li>
<li><p><strong>删除键值对：</strong></p>
<ul>
<li>使用 <code>del</code> 关键字可以删除指定的键值对。</li>
</ul>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;

# 删除键值对
del my_dict[&quot;age&quot;]
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;, &#39;city&#39;: &#39;New York&#39;&#125;
</code></pre>
<ul>
<li>使用 <code>pop()</code> 方法也可以删除指定键的键值对，并返回被删除的值。</li>
</ul>
<pre><code class="python">removed_value = my_dict.pop(&quot;city&quot;)
print(my_dict)
# 输出: &#123;&#39;name&#39;: &#39;John&#39;&#125;
print(removed_value)
# 输出: New York
</code></pre>
</li>
</ol>
<p>这些操作使得字典成为一个灵活的数据结构，可以动态地修改和管理数据。</p>
<h4><span id="字典的操作方法">字典的操作方法</span></h4><p>字典是Python中的一种数据结构，它提供了许多有用的方法和操作，使得对键值对的管理更加方便。以下是一些常见的字典操作方法：</p>
<ol>
<li><p><strong>获取字典中的值：</strong></p>
<ul>
<li><p>使用键来获取字典中对应的值。</p>
<pre><code class="python">my_dict = &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;
print(my_dict[&quot;name&quot;])  # 输出: John
</code></pre>
</li>
<li><p>使用 <code>get()</code> 方法也可以获取值，并提供默认值以避免键不存在的错误。</p>
<pre><code class="python">print(my_dict.get(&quot;country&quot;, &quot;Not specified&quot;))  # 输出: Not specified
</code></pre>
</li>
</ul>
</li>
<li><p><strong>添加新的键值对：</strong></p>
<ul>
<li><p>使用赋值语句，通过指定新的键和相应的值，向字典中添加新的键值对。</p>
<pre><code class="python">my_dict[&quot;gender&quot;] = &quot;Male&quot;
</code></pre>
</li>
<li><p>使用 <code>update()</code> 方法一次性添加多个键值对。</p>
<pre><code class="python">my_dict.update(&#123;&quot;occupation&quot;: &quot;Engineer&quot;, &quot;salary&quot;: 50000&#125;)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>更新现有的键值对：</strong></p>
<ul>
<li><p>通过指定已有的键，更新对应的值。</p>
<pre><code class="python">my_dict[&quot;age&quot;] = 31
</code></pre>
</li>
<li><p>使用 <code>update()</code> 方法也可以一次性更新多个键值对。</p>
<pre><code class="python">my_dict.update(&#123;&quot;age&quot;: 32, &quot;country&quot;: &quot;USA&quot;&#125;)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>删除键值对：</strong></p>
<ul>
<li><p>使用 <code>del</code> 关键字删除指定的键值对。</p>
<pre><code class="python">del my_dict[&quot;age&quot;]
</code></pre>
</li>
<li><p>使用 <code>pop()</code> 方法删除指定键的键值对，并返回被删除的值。</p>
<pre><code class="python">removed_value = my_dict.pop(&quot;city&quot;)
</code></pre>
</li>
<li><p>使用 <code>popitem()</code> 方法删除并返回字典中的最后一个键值对。</p>
<pre><code class="python">last_item = my_dict.popitem()
</code></pre>
</li>
</ul>
</li>
<li><p><strong>获取所有键、所有值、所有键值对：</strong></p>
<ul>
<li><p>使用 <code>keys()</code> 方法获取所有的键。</p>
<pre><code class="python">keys = my_dict.keys()
</code></pre>
</li>
<li><p>使用 <code>values()</code> 方法获取所有的值。</p>
<pre><code class="python">values = my_dict.values()
</code></pre>
</li>
<li><p>使用 <code>items()</code> 方法获取所有的键值对。</p>
<pre><code class="python">items = my_dict.items()
</code></pre>
</li>
</ul>
<p>这些方法返回的结果是视图对象，可以将其转换为列表或其他数据类型以方便使用。</p>
</li>
<li><p><strong>清空字典：</strong></p>
<ul>
<li><p>使用 <code>clear()</code> 方法清空字典中所有的键值对。</p>
<pre><code class="python">my_dict.clear()
</code></pre>
</li>
</ul>
</li>
</ol>
<p>这些操作方法使得字典在实际应用中非常灵活，能够方便地进行添加、更新、删除和查询操作。</p>
<p>深复制（deep copy）和浅复制（shallow copy）是在Python中用于复制对象的两种不同方式。它们的主要区别在于复制的对象内部包含的子对象是否也被复制。</p>
<ol>
<li><p><strong>浅复制（Shallow Copy）：</strong></p>
<ul>
<li><p>浅复制创建一个新的对象，然后将原始对象中的元素（如列表、字典等）复制到新对象中。但是，对于原始对象中的子对象（如子列表、嵌套字典等），仅复制引用而不复制实际的子对象。</p>
</li>
<li><p>在Python中，可以使用 <code>copy()</code> 方法或 <code>copy</code> 模块中的 <code>copy()</code> 函数进行浅复制。</p>
<pre><code class="python">import copy

original_list = [1, [2, 3], 4]
shallow_copy_list = copy.copy(original_list)

print(original_list)         # 输出: [1, [2, 3], 4]
print(shallow_copy_list)     # 输出: [1, [2, 3], 4]

# 修改原始列表中的元素
original_list[1][0] = 99

print(original_list)         # 输出: [1, [99, 3], 4]
print(shallow_copy_list)     # 输出: [1, [99, 3], 4]（子列表被共享）
</code></pre>
</li>
<li><p>注意：浅复制只复制了对象本身以及对象中的元素，而没有递归地复制子对象。</p>
</li>
</ul>
</li>
<li><p><strong>深复制（Deep Copy）：</strong></p>
<ul>
<li><p>深复制创建一个新的对象，并递归地复制原始对象中的所有元素，包括子对象。</p>
</li>
<li><p>在Python中，可以使用 <code>copy</code> 模块中的 <code>deepcopy()</code> 函数进行深复制。</p>
<pre><code class="python">import copy

original_list = [1, [2, 3], 4]
deep_copy_list = copy.deepcopy(original_list)

print(original_list)         # 输出: [1, [2, 3], 4]
print(deep_copy_list)        # 输出: [1, [2, 3], 4]

# 修改原始列表中的元素
original_list[1][0] = 99

print(original_list)         # 输出: [1, [99, 3], 4]
print(deep_copy_list)        # 输出: [1, [2, 3], 4]（子列表不被共享）
</code></pre>
</li>
<li><p>深复制会递归地复制整个对象结构，包括对象中的所有子对象，因此即使修改了原始对象的子对象，深复制的对象也不受影响。</p>
</li>
</ul>
</li>
</ol>
<p>选择使用浅复制还是深复制取决于应用的需求。如果对象中没有嵌套的可变对象或者不需要对嵌套的可变对象进行独立修改，那么浅复制可能足够。如果对象包含嵌套的可变对象，而且需要独立修改它们，那么深复制更合适。</p>
<h3><span id="5集合">5.集合</span></h3><p>用set()函数来创建集合</p>
<p>删除：remove（）</p>
<p>添加：add（）</p>
<p>拆分传入：update（）</p>
<pre><code class="python">a = set(&#39;i love&#39;)
a.update(&#39;python&#39;)
#&#123;&#39;i&#39;, &#39; &#39;, &#39;l&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;n&#39;&#125;
</code></pre>
<p>集合可以做数学操作</p>
<h2><span id="七异常的处理和文件操作">七，异常的处理和文件操作</span></h2><h3><span id="1异常处理">1.异常处理</span></h3><p>在Python中，异常处理是一种机制，用于捕获和处理程序执行中可能发生的异常或错误。Python提供了<code>try</code>和<code>except</code>块来实现异常处理。以下是基本的异常处理结构：</p>
<pre><code class="python">try:
    # 代码块，可能会引发异常的部分
    # ...
except ExceptionType as e:
    # 异常处理块，处理发生的特定类型的异常
    # ...
else:
    # 可选的 else 块，在没有异常发生时执行
    # ...
finally:
    # 可选的 finally 块，无论是否发生异常都会执行
    # ...
</code></pre>
<ul>
<li><code>try</code> 块包含可能引发异常的代码。</li>
<li><code>except</code> 块用于捕获并处理指定类型的异常。可以捕获多个异常类型，也可以省略异常类型捕获所有异常。</li>
<li><code>else</code> 块（可选）在没有异常发生时执行。</li>
<li><code>finally</code> 块（可选）无论是否发生异常都会执行，通常用于进行清理操作。</li>
</ul>
<p>示例：</p>
<pre><code class="python">try:
    x = 10 / 0  # 除零错误
except ZeroDivisionError as e:
    print(f&quot;Error: &#123;e&#125;&quot;)
else:
    print(&quot;No error occurred.&quot;)
finally:
    print(&quot;This will always execute.&quot;)
</code></pre>
<p>在上面的例子中，由于除零错误，控制流将跳转到<code>except</code>块，并输出错误信息。然后，<code>finally</code>块中的语句总是执行。</p>
<p>除了基本的<code>try</code>和<code>except</code>，还有其他一些关键字和语句，例如<code>raise</code>（用于手动引发异常）和<code>assert</code>（用于断言条件是否为真）。异常处理是编写健壮和容错代码的重要部分。</p>
<h3><span id="2文件操作">2.文件操作</span></h3><p>在Python中，文件操作是常见的任务之一，用于读取和写入文件。以下是一些常用的文件操作方法：</p>
<ol>
<li><p><strong>打开文件：</strong><br>使用 <code>open()</code> 函数来打开文件。该函数返回一个文件对象，可以用于读取或写入文件。</p>
<pre><code class="python"># 打开文件以供读取
file = open(&quot;example.txt&quot;, &quot;r&quot;)

# 打开文件以供写入（若文件不存在则创建）
file = open(&quot;example.txt&quot;, &quot;w&quot;)
</code></pre>
<p>参数：</p>
<ul>
<li>第一个参数是文件路径。</li>
<li>第二个参数是打开文件的模式：<ul>
<li><code>&quot;r&quot;</code>: 只读模式</li>
<li><code>&quot;w&quot;</code>: 写入模式（若文件存在则清空内容，若文件不存在则创建）</li>
<li><code>&quot;a&quot;</code>: 追加模式（在文件末尾追加内容，若文件不存在则创建）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>读取文件内容：</strong><br>使用文件对象的 <code>read()</code> 方法来读取文件内容。</p>
<pre><code class="python">content = file.read()
print(content)
</code></pre>
</li>
<li><p><strong>写入文件内容：</strong><br>使用文件对象的 <code>write()</code> 方法来写入内容到文件。</p>
<pre><code class="python">file.write(&quot;Hello, this is a sample text.&quot;)
</code></pre>
<p>要确保写入后使用 <code>close()</code> 方法关闭文件，或者使用 <code>with</code> 语句来自动关闭文件。</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;w&quot;) as file:
    file.write(&quot;Hello, this is a sample text.&quot;)
</code></pre>
</li>
<li><p><strong>逐行读取文件：</strong><br>使用文件对象的 <code>readline()</code> 方法来逐行读取文件内容。</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    line = file.readline()
    while line:
        print(line)
        line = file.readline()
</code></pre>
</li>
<li><p><strong>迭代文件对象：</strong><br>文件对象本身就是可迭代的，可以直接在 <code>for</code> 循环中使用。</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    for line in file:
        print(line)
</code></pre>
</li>
<li><p><strong>关闭文件：</strong><br>使用文件对象的 <code>close()</code> 方法来关闭文件。</p>
<pre><code class="python">file.close()
</code></pre>
<p>或者使用 <code>with</code> 语句，它会在代码块执行完毕后自动关闭文件。</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    content = file.read()
    # 文件在这里自动关闭
</code></pre>
</li>
</ol>
<p>以上是文件的基本读取和写入操作。在实际应用中，还可以使用异常处理来处理文件操作可能引发的异常，例如文件不存在、权限错误等。</p>
<p>replace函数：</p>
<p>在Python中，<code>replace()</code> 是字符串对象的方法之一，用于替换字符串中的指定子串。这个方法的基本语法如下：</p>
<pre><code class="python">str.replace(old, new[, count])
</code></pre>
<ul>
<li><code>old</code>: 要被替换的子串。</li>
<li><code>new</code>: 替换后的新子串。</li>
<li><code>count</code> (可选): 指定替换的次数。如果提供了 <code>count</code> 参数，则只替换前 <code>count</code> 次出现的子串。</li>
</ul>
<p>下面是一个简单的例子：</p>
<pre><code class="python">sentence = &quot;I love programming. Programming is fun.&quot;

# 将 &quot;Programming&quot; 替换为 &quot;Coding&quot;
new_sentence = sentence.replace(&quot;Programming&quot;, &quot;Coding&quot;)

print(new_sentence)
# 输出: &quot;I love coding. Coding is fun.&quot;
</code></pre>
<p>在上面的例子中，<code>replace()</code> 方法将字符串中所有的 “Programming” 替换为 “Coding”。</p>
<p>需要注意的是，<code>replace()</code> 方法返回一个新的字符串，原始字符串并没有被修改。如果需要修改原始字符串，可以将结果赋值给原始字符串变量。</p>
<pre><code class="python">sentence = &quot;I love programming. Programming is fun.&quot;

# 修改原始字符串
sentence = sentence.replace(&quot;Programming&quot;, &quot;Coding&quot;)

print(sentence)
# 输出: &quot;I love coding. Coding is fun.&quot;
</code></pre>
<p>这个方法在文本处理、字符串清理等场景中很常见。</p>
<h3><span id="3with语句">3.with语句</span></h3><p><code>with</code> 语句是 Python 中用于简化资源管理的一种语法结构。它通常用于对文件、网络连接、数据库连接等需要手动管理的资源进行操作，以确保在离开代码块时资源被正确释放。<code>with</code> 语句的一般形式如下：</p>
<pre><code class="python">with expression as variable:
    # 代码块，对资源进行操作
    # 在退出代码块时，确保资源被正确释放
</code></pre>
<p><code>expression</code> 是一个返回上下文管理器对象的表达式，它定义了资源的进入和退出时的操作。<code>variable</code> 是一个变量名，用于引用上下文管理器对象。</p>
<p>最常见的用法是在文件操作中，例如打开文件：</p>
<pre><code class="python">with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    content = file.read()
    # 在这里文件已经被打开
    # 在离开这个代码块时，文件会被自动关闭，不需要显式调用 file.close()
</code></pre>
<p>在上述例子中，<code>open(&quot;example.txt&quot;, &quot;r&quot;)</code> 返回一个文件对象，这个文件对象是一个上下文管理器，负责在进入和退出代码块时执行相应的操作。在 <code>with</code> 语句的代码块中，可以使用文件对象进行读取或写入操作，而在退出代码块时，文件会被自动关闭，无论代码块中是否发生异常。</p>
<p>用as关键字来取代原来的赋值语句</p>
<p><code>with</code> 语句的好处包括：</p>
<ol>
<li><p><strong>资源自动管理：</strong> 确保在代码块执行完毕后，资源会被正确释放，不需要手动调用释放资源的方法。</p>
</li>
<li><p><strong>异常处理：</strong> 在代码块中发生异常时，<code>with</code> 语句会确保退出时正确处理异常，避免资源泄漏。</p>
</li>
<li><p><strong>代码简洁：</strong> 避免了繁琐的 try-except-finally 结构，使代码更加简洁易读。</p>
</li>
</ol>
<p><code>with</code> 语句在处理一些需要管理上下文的场景中非常有用，例如文件操作、数据库连接等。</p>
<h2><span id="八面向对象编程">八，面向对象编程</span></h2><h3><span id="1类的定义与实例化">1.类的定义与实例化</span></h3><p>在Python中，构造方法是类的特殊方法，用于初始化对象的属性。构造方法的名称是固定的，它应该被命名为 <code>__init__</code>。构造方法的格式和要求如下：</p>
<pre><code class="python">class ClassName:
    def __init__(self, parameter1, parameter2, ...):
        # 构造方法的实现
        self.attribute1 = parameter1
        self.attribute2 = parameter2
        # ...
</code></pre>
<p>要点说明：</p>
<ol>
<li><p><strong>方法名称：</strong> 构造方法的名称必须是 <code>__init__</code>。</p>
</li>
<li><p><strong>参数 <code>self</code>：</strong> 构造方法的第一个参数必须是 <code>self</code>，它代表创建的对象实例。在方法内部，通过 <code>self</code> 可以访问该对象的属性和其他方法。</p>
</li>
<li><p><strong>其他参数：</strong> 构造方法可以包含除 <code>self</code> 之外的其他参数，用来接收创建对象时传递的初始值。这些参数通常用于初始化对象的属性。</p>
</li>
<li><p><strong>属性初始化：</strong> 在构造方法中，可以通过 <code>self</code> 来初始化对象的属性。例如，<code>self.attribute1 = parameter1</code> 将构造方法中传入的 <code>parameter1</code> 赋值给对象的属性 <code>attribute1</code>。</p>
</li>
</ol>
<p>示例：</p>
<pre><code class="python">class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
person1 = Person(&quot;Alice&quot;, 25)

# 访问对象的属性
print(person1.name)  # 输出: Alice
print(person1.age)   # 输出: 25
</code></pre>
<p>这是一个简单的构造方法的例子，演示了如何通过构造方法初始化对象的属性。构造方法在创建对象时自动调用，用于确保对象在被使用之前被正确初始化。</p>
<h3><span id="2类的完整定义">2.类的完整定义</span></h3><p>在Python中，一个类的完整定义包括类的名称、类的属性（成员变量）、类的方法（成员方法）以及可能的构造方法。下面是一个简单的类的完整定义示例：</p>
<pre><code class="python">class MyClass:
    # 类的属性
    class_variable = &quot;I am a class variable&quot;

    # 构造方法
    def __init__(self, param1, param2):
        self.instance_variable1 = param1
        self.instance_variable2 = param2

    # 类的方法
    def instance_method(self):
        print(&quot;I am an instance method.&quot;)

    @classmethod
    def class_method(cls):
        print(&quot;I am a class method. Class variable:&quot;, cls.class_variable)

    @staticmethod
    def static_method():
        print(&quot;I am a static method.&quot;)

# 创建一个对象实例
obj = MyClass(&quot;value1&quot;, &quot;value2&quot;)

# 访问对象的属性和调用方法
print(obj.instance_variable1)   # 输出: value1
obj.instance_method()            # 输出: I am an instance method.

# 访问类的属性和调用类方法
print(MyClass.class_variable)    # 输出: I am a class variable
MyClass.class_method()           # 输出: I am a class method. Class variable: I am a class variable

# 调用静态方法
MyClass.static_method()          # 输出: I am a static method.
</code></pre>
<p>上述代码中，<code>MyClass</code> 是一个简单的类，它包含了类的属性 <code>class_variable</code>、构造方法 <code>__init__</code>、实例方法 <code>instance_method</code>、类方法 <code>class_method</code> 和静态方法 <code>static_method</code>。在创建类的对象实例后，可以通过对象实例访问属性和调用方法，也可以通过类名访问类的属性和调用类方法。</p>
<h3><span id="3对象属性的默认值设置">3.对象属性的默认值设置</span></h3><p>在Python中，可以在类的构造方法中为对象属性设置默认值。这可以通过在构造方法中为参数提供默认值来实现。如果创建对象时没有提供特定属性的值，则使用默认值。</p>
<p>以下是一个示例，演示如何在构造方法中设置对象属性的默认值：</p>
<pre><code class="python">class Person:
    def __init__(self, name=&quot;Unknown&quot;, age=0):
        # 设置对象属性的默认值
        self.name = name
        self.age = age

# 创建对象实例，不提供任何参数，使用默认值
person1 = Person()

# 创建对象实例，提供部分参数，使用默认值
person2 = Person(name=&quot;Alice&quot;)

# 创建对象实例，提供所有参数，不使用默认值
person3 = Person(name=&quot;Bob&quot;, age=30)

# 打印对象属性
print(person1.name, person1.age)  # 输出: Unknown 0
print(person2.name, person2.age)  # 输出: Alice 0
print(person3.name, person3.age)  # 输出: Bob 30
</code></pre>
<p>在上述示例中，<code>Person</code> 类的构造方法中有两个参数 <code>name</code> 和 <code>age</code>，并为它们设置了默认值。当创建对象实例时，如果没有提供这两个参数，则会使用默认值。如果提供了参数，则使用提供的值。</p>
<p>这种方式使得对象的创建更加灵活，可以根据需要提供或者不提供特定属性的值。</p>
<h3><span id="4私有属性">4.私有属性</span></h3><p>在Python中，可以使用双下划线 (<code>__</code>) 或者单下划线（’_’）前缀来定义私有属性和私有方法。私有属性和私有方法只能在类的内部访问，外部无法直接访问它们。这有助于封装类的内部实现细节，防止外部直接修改或调用。</p>
<p>私有属性：</p>
<p>在类中定义私有属性的格式是在<strong>属性名称前</strong>加上双下划线 (<code>__</code>)。例如：</p>
<pre><code class="python">class MyClass:
    def __init__(self):
        # 定义私有属性
        self.__private_attribute = 42

    def get_private_attribute(self):
        # 在类的方法中访问私有属性
        return self.__private_attribute

# 创建对象实例
obj = MyClass()

# 无法直接访问私有属性，会引发 AttributeError
# print(obj.__private_attribute)

# 通过类的方法访问私有属性
print(obj.get_private_attribute())  # 输出: 42
</code></pre>
<p>私有方法：</p>
<p>在类中定义私有方法的格式也是在方法名称前加上双下划线 (<code>__</code>)。例如：</p>
<pre><code class="python">class MyClass:
    def __init__(self):
        pass

    # 定义私有方法
    def __private_method(self):
        return &quot;This is a private method.&quot;

    def public_method(self):
        # 在类的方法中调用私有方法
        result = self.__private_method()
        return result

# 创建对象实例
obj = MyClass()

# 无法直接调用私有方法，会引发 AttributeError
# obj.__private_method()

# 通过类的公有方法调用私有方法
print(obj.public_method())  # 输出: This is a private method.
</code></pre>
<p>在上述例子中，私有属性和私有方法只能通过类的内部方法进行访问或调用。外部无法直接访问私有属性或调用私有方法。这有助于保护类的内部实现，并提高代码的封装性。</p>
<h3><span id="5类属性">5.类属性</span></h3><p>类属性就是定义在类中的一个属性，是必须通过<strong>类名</strong>访问的属性，类的所有实例共享类属性</p>
<h3><span id="6类的继承">6.类的继承</span></h3><h4><span id="1-类的继承">（1）. 类的继承：</span></h4><p>在Python中，可以通过继承来创建一个新的类，新类称为子类，继承的类称为父类。子类可以继承父类的属性和方法，也可以添加自己的属性和方法。继承的基本语法如下：</p>
<pre><code class="python">class ParentClass:
    # 父类的属性和方法

class ChildClass(ParentClass):
    # 子类的属性和方法
</code></pre>
<h4><span id="2-子类方法对父类方法的覆盖">（2）. 子类方法对父类方法的覆盖：</span></h4><p>子类可以对父类的方法进行覆盖（重写），即在子类中定义与父类同名的方法。这样，当对象是子类的实例时，调用同名方法时将使用子类的方法而不是父类的方法。示例：</p>
<pre><code class="python">class ParentClass:
    def show_message(self):
        print(&quot;This is the parent class.&quot;)

class ChildClass(ParentClass):
    def show_message(self):
        print(&quot;This is the child class.&quot;)

# 创建子类对象
child_obj = ChildClass()

# 调用覆盖的方法
child_obj.show_message()  # 输出: This is the child class.
</code></pre>
<h4><span id="3-在子类方法中调用父类的同名方法">（3）. 在子类方法中调用父类的同名方法：</span></h4><p>如果在子类的方法中要调用父类的同名方法，可以使用 <code>super()</code> 函数。<code>super()</code> 返回父类的临时对象，可以调用父类的方法。示例：</p>
<pre><code class="python">class ParentClass:
    def show_message(self):
        print(&quot;This is the parent class.&quot;)

class ChildClass(ParentClass):
    def show_message(self):
        # 调用父类的同名方法
        super().show_message()
        print(&quot;This is the child class.&quot;)

# 创建子类对象
child_obj = ChildClass()

# 调用子类的方法
child_obj.show_message()
</code></pre>
<p>在上述例子中，<code>super().show_message()</code> 调用了父类的 <code>show_message</code> 方法，然后在子类的方法中添加了额外的输出。这样可以保留父类方法的功能，并在子类方法中进行扩展。</p>
<h2><span id="九图形的用户界面">九，图形的用户界面</span></h2><p>Tkinter是python的默认GUI库</p>
<h3><span id="1创建">1.创建</span></h3><p>在Python中，可以使用<code>tkinter</code>库创建GUI（图形用户界面）应用程序。下面是一个简单的例子，演示如何创建并运行一个基本的Tkinter GUI窗口：</p>
<p><strong>TK（）是tkinter库中的构造方法</strong></p>
<pre><code class="python">import tkinter as tk

class SimpleGUI:
    def __init__(self, master):
        self.master = master
        master.title(&quot;Simple GUI&quot;)

        self.label = tk.Label(master, text=&quot;Hello, Tkinter!&quot;)
        self.label.pack()

        self.button = tk.Button(master, text=&quot;Click Me&quot;, command=self.on_button_click)
        self.button.pack()

    def on_button_click(self):
        self.label.config(text=&quot;Button Clicked!&quot;)

# 创建主窗口
root = tk.Tk()

# 创建并运行GUI
app = SimpleGUI(root)

# 运行主循环
root.mainloop()
</code></pre>
<p>[^关于创建两次对象]: 在这两句代码中，<code>root = tk.Tk()</code> 创建了一个 Tkinter 主窗口对象，而 <code>app = SimpleGUI(root)</code> 创建了一个 <code>SimpleGUI</code> 类的对象，并将刚刚创建的 Tkinter 主窗口对象传递给它作为参数。执行的顺序通常是按照代码的顺序进行的，因此在这里，确实是先创建了 Tkinter 主窗口对象，然后创建了 <code>SimpleGUI</code> 类的对象。这种顺序通常是符合逻辑的，因为在创建 <code>SimpleGUI</code> 对象时，你可能需要传递主窗口对象，并在构造方法中进行一些初始化工作。如果反过来，先创建 <code>SimpleGUI</code> 对象，而构造方法又需要主窗口对象作为参数，那么你就需要确保在创建 <code>SimpleGUI</code> 对象之前已经有了主窗口对象。所以，这两句代码的顺序通常是按照先创建主窗口，然后再创建 GUI 对象的方式进行的。</p>
<p>这个例子创建了一个简单的Tkinter GUI窗口，包含一个标签和一个按钮。当按钮被点击时，标签的文本将被更新。以下是代码的解释：</p>
<ul>
<li><code>tk.Tk()</code> 创建了一个主窗口对象。</li>
<li><code>SimpleGUI</code> 类是我们创建的GUI应用程序的主要类。在构造方法 <code>__init__</code> 中，我们定义了窗口的标题、标签和按钮，并将它们打包（pack）到窗口中。</li>
<li><code>on_button_click</code> 方法是按钮点击事件的处理函数，它会更新标签的文本。</li>
<li><code>root.mainloop()</code> 启动了Tkinter的主循环，使窗口保持打开状态并等待用户交互。</li>
</ul>
<p>要运行这个代码，确保你的Python环境中安装了<code>tkinter</code>库，然后将代码保存为<code>.py</code>文件，运行即可看到GUI窗口。</p>
<p><strong>关于为什么要起别名：</strong></p>
<p><strong>以及是用库名来调用库中的方法</strong></p>
<p>这句代码 <code>import tkinter as tk</code> 表示导入 <code>tkinter</code> 模块，并为它起了一个别名 <code>tk</code>。这样，你可以使用 <code>tk</code> 这个别名来调用 <code>tkinter</code> 模块中的方法和类，使代码更简洁。</p>
<p>例如，原本你可能会这样写：</p>
<pre><code class="python">import tkinter

root = tkinter.Tk()
label = tkinter.Label(root, text=&quot;Hello, Tkinter!&quot;)
root.mainloop()
</code></pre>
<p>使用别名后，你可以写成：</p>
<pre><code class="python">import tkinter as tk

root = tk.Tk()
label = tk.Label(root, text=&quot;Hello, Tkinter!&quot;)
root.mainloop()
</code></pre>
<p>这样做的好处是减少代码中的重复，使代码更简洁易读。别名的选择通常是根据个人或团队的习惯，只要不与其他已有的名称冲突即可。</p>
<h3><span id="2在窗口中加入组件">2.在窗口中加入组件</span></h3><h4><span id="按钮的创建">按钮的创建</span></h4><p><strong>tk.Button</strong></p>
<p>在 Tkinter 中，可以使用 <code>Button</code> 类来创建按钮。以下是一个简单的例子，演示如何创建一个按钮：</p>
<pre><code class="python">import tkinter as tk

class SimpleGUI:
    def __init__(self, master):
        self.master = master
        master.title(&quot;Simple GUI&quot;)

        self.label = tk.Label(master, text=&quot;Hello, Tkinter!&quot;)
        self.label.pack()

        # 创建按钮
        self.button = tk.Button(master, text=&quot;Click Me&quot;, command=self.on_button_click)
        self.button.pack()

    def on_button_click(self):
        self.label.config(text=&quot;Button Clicked!&quot;)

# 创建主窗口
root = tk.Tk()

# 创建并运行 GUI
app = SimpleGUI(root)

# 运行主循环
root.mainloop()
</code></pre>
<p>在上面的例子中，通过 <code>tk.Button</code> 创建了一个按钮对象，并通过 <code>text</code> 参数设置按钮上的文本。<code>command</code> 参数指定了按钮点击时要调用的函数，这里是 <code>on_button_click</code> 方法。按钮创建后，使用 <code>pack()</code> 方法将按钮添加到主窗口中。</p>
<p>当按钮被点击时，<code>on_button_click</code> 方法会被调用，其中我们通过 <code>self.label.config()</code> 更新了标签的文本。</p>
<p>你可以根据需要自定义按钮的外观、行为以及与按钮相关联的事件处理函数。</p>
<h4><span id="按钮的动作">按钮的动作</span></h4><p><strong>command</strong></p>
<p>在Tkinter中，可以使用<code>command</code>参数为按钮设置动作事件。动作事件是指当按钮被点击时执行的操作。你可以将一个函数或方法绑定到按钮，使其在按钮被点击时调用。</p>
<p>下面是一个例子，演示如何为按钮设置动作事件：</p>
<pre><code class="python">import tkinter as tk

class SimpleGUI:
    def __init__(self, master):
        self.master = master
        master.title(&quot;Simple GUI&quot;)

        self.label = tk.Label(master, text=&quot;Hello, Tkinter!&quot;)
        self.label.pack()

        # 创建按钮并设置动作事件
        self.button = tk.Button(master, text=&quot;Click Me&quot;, command=self.on_button_click)
        self.button.pack()

    def on_button_click(self):
        self.label.config(text=&quot;Button Clicked!&quot;)
        # 在按钮点击时执行的其他操作

# 创建主窗口
root = tk.Tk()

# 创建并运行 GUI
app = SimpleGUI(root)

# 运行主循环
root.mainloop()
</code></pre>
<p>在上述例子中，<code>command=self.on_button_click</code> 将按钮的动作事件与 <code>on_button_click</code> 方法关联起来。当按钮被点击时，<code>on_button_click</code> 方法会被调用，其中我们更新了标签的文本，并可以在该方法中执行其他需要在按钮点击时进行的操作。</p>
<p>你可以根据需要定义其他的动作事件处理方法，然后将它们与按钮关联，以实现特定的功能。</p>
<h4><span id="按钮的坐标管理">按钮的坐标管理</span></h4><p>在Tkinter中，按钮的坐标管理通常通过不同的几何管理器（geometry manager）来完成。Tkinter支持三种主要的几何管理器：<code>pack</code>、<code>grid</code>和<code>place</code>。这些几何管理器允许你在窗口中放置按钮并管理它们的位置。</p>
<p>以下是每个几何管理器的简要说明：</p>
<ol>
<li><p><strong><code>pack</code> 几何管理器：</strong> <code>pack</code> 将组件放置在其父容器的边缘上，可以指定组件的位置，但默认是垂直排列。示例：</p>
<pre><code class="python">self.button.pack(side=&quot;left&quot;, padx=10, pady=10)
</code></pre>
</li>
<li><p><strong><code>grid</code> 几何管理器：</strong> <code>grid</code> 将组件放置在一个表格中，可以指定组件的行和列。示例：</p>
<pre><code class="python">self.button.grid(row=0, column=0, padx=10, pady=10)
</code></pre>
</li>
<li><p><strong><code>place</code> 几何管理器：</strong> <code>place</code> 允许你以绝对坐标放置组件，相对于其父容器的左上角。示例：</p>
<pre><code class="python">self.button.place(x=50, y=50)
</code></pre>
</li>
</ol>
<p>以下是一个完整的示例，演示如何使用<code>pack</code>、<code>grid</code>和<code>place</code>来管理按钮的坐标：</p>
<pre><code class="python">import tkinter as tk

class GeometryManagerExample:
    def __init__(self, master):
        self.master = master
        master.title(&quot;Geometry Manager Example&quot;)

        # 创建按钮并使用 pack 几何管理器
        button_pack = tk.Button(master, text=&quot;Pack&quot;)
        button_pack.pack(side=&quot;left&quot;, padx=10, pady=10)

        # 创建按钮并使用 grid 几何管理器
        button_grid = tk.Button(master, text=&quot;Grid&quot;)
        button_grid.grid(row=0, column=1, padx=10, pady=10)

        # 创建按钮并使用 place 几何管理器
        button_place = tk.Button(master, text=&quot;Place&quot;)
        button_place.place(x=100, y=50)

# 创建主窗口
root = tk.Tk()

# 创建并运行 GUI
app = GeometryManagerExample(root)

# 运行主循环
root.mainloop()
</code></pre>
<p>在这个例子中，三个按钮分别使用了<code>pack</code>、<code>grid</code>和<code>place</code>几何管理器，你可以根据需要选择适合你布局的管理器。</p>
<h3><span id="3tkinter组件及其属性">3.Tkinter组件及其属性</span></h3><h4><span id="label组件和entry组件">label组件和entry组件</span></h4><p>在Python中，<code>tkinter</code> 模块是一个常用的图形用户界面（GUI）工具包，它包含了创建窗口和各种界面元素的类和方法。<code>Label</code> 组件和 <code>Entry</code> 组件是两个常用的界面元素，用于显示文本和接收用户输入。</p>
<ol>
<li><p><strong>Label（标签）组件:</strong><br><code>Label</code> 组件用于在窗口中显示静态文本或图像。以下是一个简单的示例，演示如何创建一个标签组件：</p>
<pre><code class="python">import tkinter as tk

root = tk.Tk()
label = tk.Label(root, text=&quot;这是一个标签&quot;)
label.pack()

root.mainloop()
</code></pre>
<p>在这个例子中，创建了一个 <code>Tk</code> 窗口，并在窗口中放置了一个标签，标签上显示着文本 “这是一个标签”。</p>
</li>
<li><p><strong>Entry（输入框）组件:</strong><br><code>Entry</code> 组件用于允许用户输入文本。以下是一个简单的示例，演示如何创建一个输入框组件：</p>
<pre><code class="python">import tkinter as tk

def on_button_click():
    entered_text = entry.get()
    print(&quot;输入的文本是:&quot;, entered_text)

root = tk.Tk()

entry = tk.Entry(root)
entry.pack()

button = tk.Button(root, text=&quot;获取文本&quot;, command=on_button_click)
button.pack()

root.mainloop()
</code></pre>
<p>在这个例子中，创建了一个输入框和一个按钮。当用户输入文本并点击按钮时，程序将获取输入框中的文本并打印出来。</p>
</li>
</ol>
<p>以上代码只是简单的演示，你可以根据需要进行更复杂的界面设计和交互。希望这能帮助你开始使用 <code>Label</code> 和 <code>Entry</code> 组件。</p>
<h4><span id="listbox组件">listbox组件</span></h4><p><code>tkinter</code> 中的 <code>Listbox</code> 组件用于在窗口中显示一个列表，并允许用户选择其中的项。以下是一个简单的示例，演示如何创建和使用 <code>Listbox</code> 组件：</p>
<pre><code class="python">import tkinter as tk

def on_select(event):
    selected_item = listbox.get(listbox.curselection())
    print(&quot;选择的项是:&quot;, selected_item)

root = tk.Tk()

# 创建 Listbox 组件
listbox = tk.Listbox(root, selectmode=tk.SINGLE)
listbox.pack()

# 向 Listbox 中添加项
for item in [&quot;项1&quot;, &quot;项2&quot;, &quot;项3&quot;, &quot;项4&quot;]:
    listbox.insert(tk.END, item)

# 绑定选择事件
listbox.bind(&#39;&lt;&lt;ListboxSelect&gt;&gt;&#39;, on_select)

root.mainloop()
</code></pre>
<p>在这个例子中，创建了一个 <code>Tk</code> 窗口和一个 <code>Listbox</code> 组件。通过使用 <code>insert</code> 方法，将一些项添加到列表框中。然后，使用 <code>bind</code> 方法绑定了选择事件，当用户选择列表框中的项时，触发 <code>on_select</code> 函数。</p>
<p><code>on_select</code> 函数获取用户选择的项，并打印出来。请注意，<code>selectmode</code> 参数指定了选择模式，<code>tk.SINGLE</code> 表示只能选择一个项。</p>
<p>你可以根据需要更改选择模式，也可以使用 <code>listbox.curselection()</code> 获取当前选择的索引。这只是一个简单的示例，你可以根据实际需求进行更复杂的列表框设计。</p>
<h4><span id="canvas组件">canvas组件</span></h4><p><code>tkinter</code> 中的 <code>Canvas</code> 组件用于创建绘图区域，允许你在窗口中绘制图形、文本和其他元素。以下是一个简单的示例，演示如何创建和使用 <code>Canvas</code> 组件：</p>
<pre><code class="python">import tkinter as tk

def draw_circle():
    canvas.create_oval(50, 50, 150, 150, fill=&quot;blue&quot;)

def draw_rectangle():
    canvas.create_rectangle(200, 50, 300, 150, fill=&quot;red&quot;)

root = tk.Tk()

# 创建 Canvas 组件
canvas = tk.Canvas(root, width=400, height=200)
canvas.pack()

# 创建按钮并绑定绘制函数
circle_button = tk.Button(root, text=&quot;绘制圆形&quot;, command=draw_circle)
circle_button.pack(side=tk.LEFT)

rectangle_button = tk.Button(root, text=&quot;绘制矩形&quot;, command=draw_rectangle)
rectangle_button.pack(side=tk.LEFT)

root.mainloop()
</code></pre>
<p>在这个例子中，创建了一个 <code>Tk</code> 窗口和一个 <code>Canvas</code> 组件。通过 <code>create_oval</code> 方法和 <code>create_rectangle</code> 方法，可以在画布上绘制圆形和矩形。两个按钮分别触发 <code>draw_circle</code> 和 <code>draw_rectangle</code> 函数，绘制对应的图形。</p>
<p>可以根据需要在画布上绘制各种形状、线条、文本等。<code>Canvas</code> 组件提供了多个方法来进行绘图，可以满足各种绘图需求。</p>
<h2><span id="十数据分析与可视化">十，数据分析与可视化</span></h2><h3><span id="1数值计算库numpy">1.数值计算库numpy</span></h3><p><code>NumPy</code> 是一个用于数值计算的强大的 Python 库。它提供了一个多维数组对象（<code>numpy.ndarray</code>）和一组用于处理这些数组的函数。以下是一些 <code>NumPy</code> 的基本用法和功能：</p>
<ol>
<li><p><strong>导入 NumPy：</strong><br>在使用 NumPy 之前，需要导入它：</p>
<pre><code class="python">import numpy as np
</code></pre>
<p>通常使用 <code>np</code> 作为别名，以方便在代码中引用 NumPy。</p>
</li>
<li><p><strong>创建数组：</strong><br>使用 <code>numpy.array</code> 函数可以创建 NumPy 数组：</p>
<pre><code class="python">arr = np.array([1, 2, 3, 4, 5])
</code></pre>
<p>这样就创建了一个包含 <code>[1, 2, 3, 4, 5]</code> 的一维数组。</p>
</li>
<li><p><strong>基本操作：</strong><br>NumPy 数组支持基本的数学运算，例如加法、减法、乘法和除法：</p>
<pre><code class="python">a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

result = a + b
</code></pre>
<p><code>result</code> 将包含 <code>[5, 7, 9]</code>。</p>
</li>
<li><p><strong>多维数组：</strong><br>NumPy 支持多维数组，可以创建二维、三维等数组：</p>
<pre><code class="python">matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
</code></pre>
<p>这是一个3x3的二维数组。</p>
</li>
<li><p><strong>数组索引和切片：</strong><br>NumPy 数组可以通过索引和切片进行访问和操作：</p>
<pre><code class="python">a = np.array([1, 2, 3, 4, 5])
print(a[2])  # 输出: 3
</code></pre>
<p>或者：</p>
<pre><code class="python">matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(matrix[1, 2])  # 输出: 6
</code></pre>
</li>
<li><p><strong>数学函数：</strong><br>NumPy 提供了许多数学函数，如 <code>np.sin</code>、<code>np.cos</code>、<code>np.exp</code> 等，可以在数组上进行元素级别的操作。</p>
<pre><code class="python">angles = np.array([0, np.pi/2, np.pi])
sin_values = np.sin(angles)
</code></pre>
<p><code>sin_values</code> 将包含 <code>[0, 1, 0]</code>。</p>
</li>
</ol>
<p>这只是 NumPy 的一小部分功能，它还包括线性代数、统计、随机数生成等功能。</p>
<h3><span id="2科学计算扩展库scipy">2.科学计算扩展库scipy</span></h3><p><code>SciPy</code> 是建立在 <code>NumPy</code> 基础上的科学计算扩展库，它提供了许多用于解决科学和工程问题的高级功能。<code>SciPy</code> 包含了许多子模块，每个子模块都专注于解决特定类型的问题。以下是一些 <code>SciPy</code> 子模块和其功能的简要介绍：</p>
<ol>
<li><p><strong>插值（Interpolation）：</strong><br><code>scipy.interpolate</code> 模块提供了插值函数，用于在给定数据点之间进行插值。</p>
</li>
<li><p><strong>优化（Optimization）：</strong><br><code>scipy.optimize</code> 模块包含了各种最优化算法，用于寻找函数的最小值或最大值。</p>
</li>
<li><p><strong>线性代数（Linear Algebra）：</strong><br><code>scipy.linalg</code> 模块扩展了 <code>NumPy</code> 的线性代数功能，提供了更多的线性代数操作。</p>
</li>
<li><p><strong>信号处理（Signal Processing）：</strong><br><code>scipy.signal</code> 模块包含了许多信号处理工具，如滤波、频谱分析等。</p>
</li>
<li><p><strong>统计（Statistics）：</strong><br><code>scipy.stats</code> 模块包含了统计学函数，用于执行各种统计分析。</p>
</li>
<li><p><strong>积分（Integration）：</strong><br><code>scipy.integrate</code> 模块提供了积分函数，用于数值积分和微分方程求解。</p>
</li>
<li><p><strong>图像处理（Image Processing）：</strong><br><code>scipy.ndimage</code> 模块包含了用于图像处理的函数，如滤波、形态学操作等。</p>
</li>
<li><p><strong>稀疏矩阵（Sparse Matrix）：</strong><br><code>scipy.sparse</code> 模块提供了用于处理大规模稀疏矩阵的工具，包括线性代数操作。</p>
</li>
<li><p><strong>空间距离（Spatial distance）：</strong><br><code>scipy.spatial</code> 模块包含了用于计算空间距离的函数，如距离矩阵的计算等。</p>
</li>
</ol>
<p>以上只是 <code>SciPy</code> 的一些功能模块，它还包括其他一些子模块，每个子模块都提供了一组相关的工具和算法。通过结合 <code>NumPy</code> 和 <code>SciPy</code>，你可以进行更广泛领域的科学计算和数据分析。</p>
<h3><span id="3数值计算可视化库matplotlib">3.数值计算可视化库matplotlib</span></h3><p><code>matplotlib</code> 是一个用于绘制二维图形的强大可视化库，主要用于数据可视化、绘制图表和图形等。它支持多种绘图风格，可以用于创建线图、散点图、柱状图、饼图等各种图表类型。以下是一些 <code>matplotlib</code> 的基本用法和功能：</p>
<ol>
<li><p><strong>导入 matplotlib：</strong><br>在使用 matplotlib 之前，需要导入它：</p>
<pre><code class="python">import matplotlib.pyplot as plt
</code></pre>
<p>通常使用 <code>plt</code> 作为别名。</p>
</li>
<li><p><strong>绘制简单的线图：</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt

# 创建数据
x = [1, 2, 3, 4, 5]
y = [2, 4, 6, 8, 10]

# 绘制线图
plt.plot(x, y)

# 显示图形
plt.show()
</code></pre>
</li>
<li><p><strong>散点图：</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt

# 创建数据
x = [1, 2, 3, 4, 5]
y = [2, 4, 6, 8, 10]

# 绘制散点图
plt.scatter(x, y)

# 显示图形
plt.show()
</code></pre>
</li>
<li><p><strong>柱状图：</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt

# 创建数据
categories = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]
values = [3, 7, 2, 5]

# 绘制柱状图
plt.bar(categories, values)

# 显示图形
plt.show()
</code></pre>
</li>
<li><p><strong>饼图：</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt

# 创建数据
sizes = [25, 30, 20, 25]
labels = [&#39;Category A&#39;, &#39;Category B&#39;, &#39;Category C&#39;, &#39;Category D&#39;]

# 绘制饼图
plt.pie(sizes, labels=labels, autopct=&#39;%1.1f%%&#39;)

# 显示图形
plt.show()
</code></pre>
</li>
</ol>
<p>这只是 <code>matplotlib</code> 的一小部分功能，它还支持自定义图表样式、添加标签、网格线等。<code>matplotlib</code> 可以与 <code>NumPy</code> 和 <code>SciPy</code> 结合使用，以实现更复杂的数据分析和可视化任务。</p>

    </div>
    
    
    
    
    
    
    
</div>
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 PHM&#39;s world
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;ailasukasan
        </div>
        <div>
            可以点击一下Try Try <a target="_blank" rel="noopener" href="https://github.com/ailasukasan">歡迎來到我的世界</a> &amp;
            <a href="">站在能分割世界的桥</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>


        
    </div>
    <script src="/js/main.js"></script>
    
    




    


</body>
</html>
